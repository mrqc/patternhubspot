# Enabling Team — Organizational Team Pattern

## Pattern Name and Classification

**Name:** Enabling Team  
**Classification:** Organizational Team Pattern (Team Topologies) — Supportive/Facilitating Team

## Intent

Reduce cognitive load on stream-aligned teams by proactively **accelerating adoption of new skills, practices, and platforms** through coaching, lightweight tooling, and “paved road” templates—without taking long-term ownership of delivery.

## Also Known As

-   Capability Accelerator
    
-   Coaching Team
    
-   Tech Enablement / Enablement Guild
    
-   Developer Productivity (when focused on inner platform & paved roads)
    

## Motivation (Forces)

-   **Cognitive load vs. delivery pressure:** Stream-aligned teams must deliver user value but can’t simultaneously master every new practice or platform.
    
-   **Rapidly changing tech landscape:** Secure-by-default, cloud, data, and platform practices evolve faster than product teams can keep up.
    
-   **Local vs. global optimization:** Teams locally improvise tooling; organizations need consistency and safety rails.
    
-   **Knowledge diffusion:** Tacit knowledge (ops, security, testing) rarely spreads via docs alone; it needs coaching and exemplars.
    
-   **Avoid dependency traps:** Central experts must help teams become self-sufficient rather than becoming delivery bottlenecks.
    

## Applicability

Use an Enabling Team when:

-   Many stream-aligned teams need to **adopt a new capability** (e.g., observability, trunk-based development, threat modeling, event-driven architecture).
    
-   Incidents or lead times indicate **gaps in engineering practices** (e.g., flaky tests, poor SLOs, missing security controls).
    
-   A platform exists but **isn’t being adopted** due to steep learning curves.
    
-   You need **organization-wide consistency** (e.g., golden pipelines, secure defaults) without centralizing delivery.
    
-   A transformation (cloud, data mesh, DevSecOps) requires **coaching + paved roads** more than mandates.
    

## Structure

```css
┌───────────────────────────┐
               │        Leadership         │
               └─────────────┬─────────────┘
                             │
                Enablement Mission & OKRs
                             │
               ┌─────────────▼─────────────┐
               │       Enabling Team       │
               │  (coaches + builders)     │
               └─────────────┬─────────────┘
           Time-boxed, goal-oriented engagements
 ┌───────────────▼───────────────┐   ┌───────────────▼───────────────┐
 │       Stream-Aligned Team A    │   │       Stream-Aligned Team B    │
 │ (delivery ownership retained)  │   │ (delivery ownership retained)  │
 └────────────────────────────────┘   └────────────────────────────────┘
             ▲           ▲
             │ Feedback  │ Inner source contributions
             └───────────┴───────────────────────────► Platform/Guardrails
```

## Participants

-   **Enabling Team:** Senior engineers, SREs, security, QA, data, or platform specialists skilled in *teaching by doing*.
    
-   **Stream-Aligned Teams:** Product teams owning value streams; temporary recipients of enablement.
    
-   **Platform Team(s):** Provide reusable building blocks; Enabling Team lowers adoption friction and surfaces gaps.
    
-   **Leadership:** Sets outcomes and removes org impediments; protects time for coaching and learning.
    

## Collaboration

-   **Time-boxed engagement:** 2–12 weeks per team with explicit outcomes (e.g., “green SLO dashboard,” “CD pipeline v1 in production”).
    
-   **Pairing & mobbing:** Coach embeds with stream team to build capabilities hands-on.
    
-   **Paved road artifacts:** Starters, templates, linters, workshops, checklists, playbooks.
    
-   **Exit criteria:** Clear capability handover; stream team can operate independently; Enabling Team disengages.
    
-   **Feedback loop:** Capture friction → improve platform/docs → update templates; publicize wins to drive adoption.
    

## Consequences

**Benefits**

-   Faster, safer adoption of good practices and platforms.
    
-   Reduced cognitive load; improved lead time, MTTR, and change fail rate.
    
-   Consistent, secure-by-default delivery with less central gatekeeping.
    
-   Knowledge spreads; fewer “hero” bottlenecks.
    

**Liabilities / Trade-offs**

-   Risk of becoming a **shadow delivery team** if scope isn’t guarded.
    
-   If engagements aren’t time-boxed, **dependence** and **queueing** reappear.
    
-   Requires strong coaching skills (not just technical depth).
    
-   Metrics can be indirect; outcomes need careful definition.
    

## Implementation

1.  **Define mission & boundaries**
    
    -   Charter: accelerate capability adoption; no long-term delivery ownership.
        
    -   Engagement model: request → triage → discovery → time-boxed engagement → exit review.
        
2.  **Staffing & skills**
    
    -   Blend senior engineers with coaching aptitude; rotate to avoid burnout and siloing.
        
3.  **Backlog & triage**
    
    -   Intake form scoped by outcomes; prioritize by impact (value stream criticality, incident history, platform ROI).
        
4.  **Playbooks & paved roads**
    
    -   Golden pipeline, service template, observability starter, security scaffolds (threat model template, SBOM, dependency scanning), data governance starter.
        
5.  **Work with platform team(s)**
    
    -   Treat friction as product feedback; co-own adoption metrics; inner-source contributions.
        
6.  **Measure outcomes**
    
    -   Before/after metrics: lead time, CFR, MTTR, p95 build duration, test pass rate, onboarding time, % services on paved road.
        
7.  **Exit criteria**
    
    -   Documented runbooks; team demo; capability self-assessment meets threshold; coach disengages.
        
8.  **Anti-patterns to avoid**
    
    -   Ticket factory, policy police, indefinite embedding, tool dumping without coaching, “big-bang” mandates.
        

## Sample Code (Java)

*Example of a small “paved road” component an Enabling Team might provide: an opinionated HTTP client with standardized timeouts, retries, and tracing headers—packaged so stream teams can adopt resilient, observable calls with minimal cognitive load.*

```java
package dev.pavedroad.http;

import java.io.IOException;
import java.net.URI;
import java.net.http.*;
import java.time.Duration;
import java.util.Map;
import java.util.concurrent.ThreadLocalRandom;

public final class PavedHttpClient {

  private final HttpClient client;
  private final int maxRetries;
  private final Duration baseBackoff;
  private final Duration timeout;

  public static Builder builder() { return new Builder(); }

  private PavedHttpClient(HttpClient client, int maxRetries, Duration baseBackoff, Duration timeout) {
    this.client = client;
    this.maxRetries = maxRetries;
    this.baseBackoff = baseBackoff;
    this.timeout = timeout;
  }

  public HttpResponse<String> get(URI uri, Map<String, String> headers, TraceContext trace) throws IOException, InterruptedException {
    HttpRequest request = applyDefaults(HttpRequest.newBuilder(uri), headers, trace).GET().build();
    return executeWithRetry(request);
  }

  public HttpResponse<String> postJson(URI uri, String body, Map<String, String> headers, TraceContext trace) throws IOException, InterruptedException {
    HttpRequest request = applyDefaults(HttpRequest.newBuilder(uri), headers, trace)
        .POST(HttpRequest.BodyPublishers.ofString(body))
        .header("Content-Type", "application/json")
        .build();
    return executeWithRetry(request);
  }

  private HttpRequest.Builder applyDefaults(HttpRequest.Builder b, Map<String, String> headers, TraceContext trace) {
    b.timeout(timeout);
    // Minimal W3C Trace Context propagation
    b.header("traceparent", trace.toTraceparent());
    if (headers != null) headers.forEach(b::header);
    // Secure-by-default: disallow plain text unless explicitly passed
    b.header("X-Paved-Client", "true");
    return b;
  }

  private HttpResponse<String> executeWithRetry(HttpRequest request) throws IOException, InterruptedException {
    IOException lastIo = null;
    HttpResponse<String> lastResp = null;

    for (int attempt = 0; attempt <= maxRetries; attempt++) {
      try {
        lastResp = client.send(request, HttpResponse.BodyHandlers.ofString());
        int sc = lastResp.statusCode();
        if (sc < 500 && sc != 429) return lastResp; // success or non-retriable
      } catch (IOException ioe) {
        lastIo = ioe; // transient?
      }

      if (attempt < maxRetries) backoff(attempt);
    }

    if (lastIo != null) throw lastIo;
    return lastResp; // may be 5xx or 429 after retries
  }

  private void backoff(int attempt) throws InterruptedException {
    long jitter = ThreadLocalRandom.current().nextLong(25, 125);
    long sleepMs = (long) Math.min(baseBackoff.toMillis() * Math.pow(2, attempt) + jitter, 10_000);
    Thread.sleep(sleepMs);
  }

  public static final class Builder {
    private int maxRetries = 2;
    private Duration baseBackoff = Duration.ofMillis(200);
    private Duration timeout = Duration.ofSeconds(3);
    private HttpClient client = HttpClient.newBuilder()
        .connectTimeout(Duration.ofSeconds(3))
        .version(HttpClient.Version.HTTP_2)
        .build();

    public Builder maxRetries(int v) { this.maxRetries = v; return this; }
    public Builder baseBackoff(Duration d) { this.baseBackoff = d; return this; }
    public Builder timeout(Duration d) { this.timeout = d; return this; }
    public Builder client(HttpClient c) { this.client = c; return this; }
    public PavedHttpClient build() { return new PavedHttpClient(client, maxRetries, baseBackoff, timeout); }
  }

  /** Minimal trace context used by paved road libs */
  public static final class TraceContext {
    private final String traceId; // 16 bytes hex
    private final String spanId;  // 8 bytes hex
    private final String flags;   // e.g., "01"

    public TraceContext(String traceId, String spanId, String flags) {
      this.traceId = traceId;
      this.spanId = spanId;
      this.flags = flags;
    }
    public String toTraceparent() { return "00-" + traceId + "-" + spanId + "-" + flags; }
    public static TraceContext random() {
      return new TraceContext(hex(16), hex(8), "01");
    }
    private static String hex(int bytes) {
      StringBuilder sb = new StringBuilder(bytes * 2);
      ThreadLocalRandom r = ThreadLocalRandom.current();
      for (int i = 0; i < bytes; i++) sb.append(String.format("%02x", r.nextInt(256)));
      return sb.toString();
    }
  }
}
```

*Usage in a stream-aligned service (adopting the paved road with minimal code):*

```java
import dev.pavedroad.http.PavedHttpClient;
import dev.pavedroad.http.PavedHttpClient.TraceContext;

import java.net.URI;
import java.net.http.HttpResponse;
import java.util.Map;

public class CustomerClient {

  private final PavedHttpClient http = PavedHttpClient.builder()
      .maxRetries(3)
      .timeout(java.time.Duration.ofSeconds(2))
      .build();

  public String fetchCustomer(String id) {
    try {
      HttpResponse<String> resp = http.get(
          URI.create("https://customer.internal/api/v1/customers/" + id),
          Map.of("Accept", "application/json"),
          TraceContext.random()
      );
      if (resp.statusCode() == 200) return resp.body();
      throw new RuntimeException("Upstream error: " + resp.statusCode());
    } catch (Exception e) {
      // Standardized error handling path promoted by the enabling team
      throw new RuntimeException("Failed to fetch customer", e);
    }
  }
}
```

**Why this helps:** The Enabling Team provides an opinionated, secure-by-default client (timeouts, retries, trace propagation) so product teams don’t have to rediscover reliability/observability basics. The same idea extends to **service templates**, **test harnesses**, **security adapters**, and **pipeline blueprints**.

## Known Uses

-   **Team Topologies** (Skelton & Pais): Enabling Team as one of four fundamental team types used across many orgs adopting modern delivery.
    
-   **GOV.UK / GDS**: Coaching & guidance teams accelerating platform and engineering practice adoption.
    
-   **Spotify**: Agile coaches and enabling guilds supporting squads to adopt new practices without taking ownership of delivery.
    
-   **Large tech companies**: Developer Productivity / Developer Experience (DevEx) groups providing paved roads and coaching for platform adoption.
    

## Related Patterns

-   **Platform Team:** Provides underlying services/products; Enabling Team accelerates adoption and feeds back friction.
    
-   **Stream-Aligned Team:** Primary customer of enablement; owns delivery.
    
-   **Complicated-Subsystem Team:** May need targeted enablement to share specialized knowledge.
    
-   **Communities of Practice (Guilds):** Persistent knowledge-sharing structures complementary to time-boxed enablement.
    
-   **Blue/Green, Canary, CI/CD (Deployment Patterns):** Common enablement targets delivered via templates and coaching.
    
-   **InnerSource:** Mechanism for teams to contribute improvements to paved roads and platform components.

You: 

Fill out the following chapters for the Organizational Team Pattern "Feature Team": Pattern Name and Classification, Intent, Also Known As, Motivation (Forces), Applicability, Structure, Participants, Collaboration, Consequences, Implementation, Sample Code, Known Uses, Related Patterns In case code is useful provide a sample code in Java. Start with the pattern name and topic as title. Proceed with the chapters as listed. Do not provide any questions in the end.

ChatGPT: 

# Feature Team — Organizational Team Pattern

## Pattern Name and Classification

**Name:** Feature Team  
**Classification:** Organizational Team Pattern — Delivery-Focused, Cross-Functional Team

## Intent

Create long-lived, cross-functional teams capable of delivering end-to-end customer features across multiple components or subsystems, thereby avoiding silos of specialized teams and reducing handoffs.

## Also Known As

-   Cross-Component Team
    
-   Vertical Slice Team
    
-   End-to-End Feature Development Team
    

## Motivation (Forces)

-   **Reduce handoffs:** Traditional component teams require coordination and create delays.
    
-   **End-to-end accountability:** Teams should own delivery from UX to backend to testing.
    
-   **Customer-centric focus:** Features delivered align with business value, not just technical modules.
    
-   **Learning & ownership:** Team members broaden skills, reducing bottlenecks tied to specialized silos.
    
-   **Delivery predictability:** A stable team structure allows sustainable throughput.
    

Forces at play:

-   Need for faster time-to-market.
    
-   Desire for higher quality by removing integration risks across teams.
    
-   Requirement for continuous flow rather than project-based staffing.
    

## Applicability

Apply when:

-   The product spans multiple layers (UI, API, database, infrastructure).
    
-   End-to-end feature delivery is slowed by coordination across component teams.
    
-   Organization wants to maximize autonomy of teams while ensuring customer focus.
    
-   A domain is stable enough that long-lived teams can own slices of functionality.
    

Do not apply when:

-   The system requires deep expertise in highly specialized subsystems that few can master (use Complicated Subsystem Teams instead).
    
-   The architecture is highly coupled, making end-to-end work across slices inefficient.
    

## Structure

```pgsql
┌───────────────────────────────┐
│        Product Management      │
└───────────────┬───────────────┘
                │
                ▼
      ┌─────────────────────┐
      │     Feature Team    │
      │ (cross-functional)  │
      │ - Product Owner     │
      │ - Developers        │
      │ - QA/Testers        │
      │ - UX/UI Designers   │
      │ - Ops/DevOps        │
      └──────────┬──────────┘
                 │
     End-to-End Features across subsystems
                 │
     ┌───────────▼───────────┐
     │ UI │ API │ Database │ Infra │
     └───────────────────────┘
```

## Participants

-   **Product Owner:** Prioritizes backlog and aligns team with business goals.
    
-   **Developers:** Implement full-stack functionality.
    
-   **Testers/QA:** Ensure feature quality via automation and exploratory testing.
    
-   **UX/UI Designers:** Ensure usability and design consistency.
    
-   **Ops/DevOps/SREs:** Build deployment pipelines, observability, and production-readiness.
    

## Collaboration

-   Collaborate daily within the team across roles (scrum, kanban, or other agile frameworks).
    
-   Close interaction with stakeholders and customers for feedback loops.
    
-   Continuous integration ensures rapid validation of features.
    
-   Pairing/mobbing across disciplines to share knowledge and reduce silos.
    

## Consequences

**Benefits**

-   End-to-end delivery of customer value without dependencies.
    
-   Reduced lead times and fewer coordination delays.
    
-   Broader skill development inside teams (T-shaped individuals).
    
-   Higher autonomy and ownership.
    

**Liabilities / Trade-offs**

-   Risk of shallow expertise in deeply complex subsystems.
    
-   Requires significant investment in DevOps practices and automation to enable independence.
    
-   Teams may duplicate solutions without coordination (risk of inconsistency).
    
-   Onboarding may take longer as members need broad knowledge.
    

## Implementation

1.  **Team Formation**
    
    -   Form stable teams of 5–9 people.
        
    -   Ensure mix of skills: frontend, backend, QA, UX, Ops.
        
    -   Align team with a long-lived product area or customer journey.
        
2.  **Backlog Management**
    
    -   Define work as **features** (end-to-end slices) instead of component tasks.
        
    -   Prioritize features in collaboration with product management.
        
3.  **Engineering Practices**
    
    -   CI/CD pipeline per team for independent deployability.
        
    -   Feature toggles for gradual rollouts.
        
    -   Automated testing (unit, integration, end-to-end).
        
    -   Monitoring & observability for production ownership.
        
4.  **Working Agreements**
    
    -   Shared coding standards, DoD (Definition of Done), and testing guidelines.
        
    -   Regular retrospectives to improve collaboration and process.
        
5.  **Tooling & Infrastructure**
    
    -   Templates and paved-road setups to reduce overhead.
        
    -   Shared libraries or platform services provided by platform/enabling teams.
        

## Sample Code (Java)

*Example: A Feature Team implements an end-to-end "Create Customer" feature touching API, service, and persistence.*

```java
// REST Controller - part of feature slice
@RestController
@RequestMapping("/api/customers")
public class CustomerController {

    private final CustomerService service;

    public CustomerController(CustomerService service) {
        this.service = service;
    }

    @PostMapping
    public ResponseEntity<CustomerDto> createCustomer(@RequestBody CustomerDto dto) {
        Customer customer = service.createCustomer(dto);
        return ResponseEntity.status(HttpStatus.CREATED)
                             .body(CustomerDto.fromEntity(customer));
    }
}

// Service Layer
@Service
public class CustomerService {

    private final CustomerRepository repository;

    public CustomerService(CustomerRepository repository) {
        this.repository = repository;
    }

    public Customer createCustomer(CustomerDto dto) {
        Customer entity = new Customer(dto.getName(), dto.getEmail());
        return repository.save(entity);
    }
}

// Repository Layer
@Entity
@Table(name = "customers")
public class Customer {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;
    private String email;

    protected Customer() {}
    public Customer(String name, String email) {
        this.name = name;
        this.email = email;
    }
    // getters/setters omitted
}

public interface CustomerRepository extends JpaRepository<Customer, Long> { }

// DTO
public record CustomerDto(Long id, String name, String email) {
    public static CustomerDto fromEntity(Customer c) {
        return new CustomerDto(c.getId(), c.getName(), c.getEmail());
    }
}
```

**Why this helps:** A Feature Team owns the entire stack for delivering this functionality (REST endpoint, business logic, persistence). Testing, deployment, and UX are integrated in the team’s work.

## Known Uses

-   **Scrum Teams** in agile transformations often adopt a feature team model.
    
-   **Spotify Squads:** Autonomous teams delivering features end-to-end within a product area.
    
-   **Microsoft and Google:** Product teams organized around features rather than components.
    
-   **Scaled Agile Framework (SAFe):** Feature teams are recommended for Agile Release Trains.
    

## Related Patterns

-   **Cross-Functional Team:** Similar principle, broader emphasis on skill diversity.
    
-   **Stream-Aligned Team (Team Topologies):** A feature team is a concrete example of stream-aligned.
    
-   **Component Team:** Opposite pattern; focused on subsystem/component delivery only.
    
-   **Enabling Team:** Supports feature teams with adoption of new capabilities.
    
-   **Platform Team:** Provides foundational services so feature teams can focus on end-to-end value.

You: 

Fill out the following chapters for the Organizational Team Pattern "Guilds and Chapters": Pattern Name and Classification, Intent, Also Known As, Motivation (Forces), Applicability, Structure, Participants, Collaboration, Consequences, Implementation, Sample Code, Known Uses, Related Patterns In case code is useful provide a sample code in Java. Start with the pattern name and topic as title. Proceed with the chapters as listed. Do not provide any questions in the end.

ChatGPT: 

# Guilds and Chapters — Organizational Team Pattern

## Pattern Name and Classification

**Name:** Guilds and Chapters  
**Classification:** Organizational Team Pattern — Knowledge Sharing and Alignment Structures (originated from Spotify model)

## Intent

Enable knowledge sharing, alignment, and community-building across multiple autonomous teams by creating informal, cross-cutting groups (guilds) and discipline-specific groups (chapters) that spread best practices, reduce silos, and build professional identity within the organization.

## Also Known As

-   Communities of Practice (for Guilds)
    
-   Discipline Circles (for Chapters)
    
-   Practice Groups
    
-   Expert Communities
    

## Motivation (Forces)

-   **Autonomy vs. alignment:** Teams need autonomy to deliver, but organizations require consistency in practices and standards.
    
-   **Knowledge diffusion:** Critical expertise (security, QA, DevOps, UX) can get siloed in feature teams.
    
-   **Career growth and identity:** Specialists need peer recognition beyond their delivery team.
    
-   **Sustainability:** Without shared learning, organizations reinvent solutions inconsistently.
    
-   **Scaling:** As organizations grow, informal knowledge-sharing mechanisms no longer suffice.
    

## Applicability

Use Guilds and Chapters when:

-   The organization consists of many autonomous or feature teams.
    
-   There is a risk of siloed knowledge across teams.
    
-   Shared practices (coding standards, testing strategies, DevOps pipelines) are required.
    
-   Employees want communities for learning and career identity beyond their team context.
    
-   Scaling agile practices (Spotify, SAFe, LeSS) where both autonomy and alignment are valued.
    

Do not apply when:

-   The organization is very small, where informal sharing suffices.
    
-   The organization enforces strict central mandates instead of encouraging community ownership.
    

## Structure

```scss
┌─────────────────────────┐
                       │         Tribe            │
                       │ (collection of squads)   │
                       └───────┬─────────────────┘
                               │
          ┌────────────────────┼─────────────────────┐
          │                                            │
 ┌────────▼─────────┐                        ┌────────▼─────────┐
 │      Chapter      │                        │      Chapter      │
 │ Discipline-based  │                        │ Discipline-based  │
 │ (e.g., QA, iOS)   │                        │ (e.g., Backend)  │
 └────────┬─────────┘                        └────────┬─────────┘
          │                                           │
      Members across squads                     Members across squads
          │                                           │
          └───────────────────┬───────────────────────┘
                              │
                       ┌──────▼───────┐
                       │    Guild     │
                       │ Cross-org    │
                       │ interest grp │
                       └──────────────┘
```

-   **Chapter:** Small discipline-specific unit (led by a Chapter Lead, often the line manager), ensuring consistent standards.
    
-   **Guild:** Large, voluntary, cross-cutting community of interest (e.g., “Testing Guild,” “Data Guild”) open to anyone passionate about the topic.
    

## Participants

-   **Chapter Lead:** Provides mentoring, ensures alignment in practices, often line manages members of the chapter.
    
-   **Chapter Members:** Individuals in the same discipline spread across squads.
    
-   **Guild Coordinators:** (Optional) facilitate the larger community, organize meetups, maintain shared assets.
    
-   **Squad Members:** Contribute to chapters and guilds while focusing on squad delivery.
    

## Collaboration

-   **Chapters:** Regular meetings (bi-weekly/monthly), maintain coding guidelines, review practices, align on tooling.
    
-   **Guilds:** Larger meetups, unconferences, workshops, slack channels; voluntary participation.
    
-   **Artifacts:** Shared documentation, playbooks, templates, libraries, starter kits.
    
-   **Communication:** Bi-directional: knowledge from practice communities flows back into squads, and squad learnings improve guild/chapter guidance.
    

## Consequences

**Benefits**

-   Knowledge sharing across autonomous teams.
    
-   Professional identity and career development for specialists.
    
-   Reduced duplication and inconsistencies in practices.
    
-   Communities foster innovation and peer support.
    

**Liabilities / Trade-offs**

-   Risk of **guilds becoming talk-shops** without impact if not connected to delivery.
    
-   Requires time investment beyond feature work; may slow immediate delivery.
    
-   Chapters can morph into hierarchical control, reducing autonomy.
    
-   Misalignment between guild guidance and squad priorities can create tension.
    

## Implementation

1.  **Identify Disciplines and Interests**
    
    -   Define chapters for essential disciplines (QA, Backend, Mobile, UX).
        
    -   Create guilds for broad topics (DevOps, Security, Data Science).
        
2.  **Appoint Chapter Leads**
    
    -   Experienced practitioners who also line manage within the discipline.
        
3.  **Enable Guild Formation**
    
    -   Voluntary membership; anyone can join based on passion.
        
    -   Provide tooling: Slack channels, Confluence, mailing lists, regular meetups.
        
4.  **Balance Autonomy and Alignment**
    
    -   Encourage but don’t mandate adoption of guild/chapter standards.
        
    -   Use lightweight governance (templates, guidelines, starter projects).
        
5.  **Events & Rituals**
    
    -   Guild days / hack days / unconferences.
        
    -   Chapter syncs for standardization and peer reviews.
        
6.  **Feedback Loop**
    
    -   Gather squad feedback on guidelines and iterate.
        
    -   Ensure guild outputs (e.g., libraries, pipelines) are actually usable.
        
7.  **Measure Success**
    
    -   Adoption of shared practices.
        
    -   Reduced defects due to common tooling.
        
    -   Employee satisfaction and retention.
        

## Sample Code (Java)

*Example: A Chapter (Backend Chapter) defines common coding standards and provides a reusable library to all squads. This ensures consistency across teams while allowing autonomy in feature delivery.*

```java
// Shared library provided by Backend Chapter
package com.company.common.validation;

public class EmailValidator {

    private static final String EMAIL_PATTERN =
            "^[A-Za-z0-9+_.-]+@[A-Za-z0-9.-]+$";

    private EmailValidator() {}

    public static boolean isValid(String email) {
        return email != null && email.matches(EMAIL_PATTERN);
    }
}

// Usage in different squads (feature teams)
package com.company.customer;

import com.company.common.validation.EmailValidator;

public class CustomerRegistrationService {

    public void registerCustomer(String email) {
        if (!EmailValidator.isValid(email)) {
            throw new IllegalArgumentException("Invalid email address");
        }
        // proceed with registration logic
    }
}
```

**Why this helps:**

-   A **Chapter** provides the common validator, ensuring consistent rules across squads.
    
-   A **Guild** (e.g., “Quality Guild”) may organize a workshop to discuss input validation, security aspects, and share improvements.
    

## Known Uses

-   **Spotify Model:** Guilds and Chapters are central to its scaling model.
    
-   **ING Bank:** Adopted guilds and chapters in their agile transformation.
    
-   **Ericsson, LEGO, Zalando:** Use communities of practice/guilds for knowledge diffusion.
    
-   **Scaled Agile Framework (SAFe):** Uses Communities of Practice, equivalent to guilds.
    

## Related Patterns

-   **Feature Team:** Autonomous delivery teams that guilds/chapters support.
    
-   **Cross-Functional Team:** Chapter/Guild ensures depth while teams remain broad.
    
-   **Enabling Team:** Focuses on adoption; guilds spread knowledge informally.
    
-   **Communities of Practice:** The academic origin of guilds in agile organizations.
    
-   **Platform Team:** Provides shared infrastructure, often influenced by guilds.

You: 

Fill out the following chapters for the Organizational Team Pattern "Inverse Conway Maneuver": Pattern Name and Classification, Intent, Also Known As, Motivation (Forces), Applicability, Structure, Participants, Collaboration, Consequences, Implementation, Sample Code, Known Uses, Related Patterns In case code is useful provide a sample code in Java. Start with the pattern name and topic as title. Proceed with the chapters as listed. Do not provide any questions in the end.

ChatGPT: 

# Inverse Conway Maneuver — Organizational Team Pattern

## Pattern Name and Classification

**Name:** Inverse Conway Maneuver  
**Classification:** Organizational Team Pattern — Strategic Alignment Pattern (Team Topologies / Software Architecture Governance)

## Intent

Deliberately design and adapt organizational team structures to **mirror the desired software architecture** rather than letting the architecture emerge accidentally from existing organizational silos (as predicted by Conway’s Law).

## Also Known As

-   Reverse Conway Maneuver
    
-   Team-Driven Architecture Shaping
    
-   Organizational Refactoring
    

## Motivation (Forces)

-   **Conway’s Law:** “Any organization that designs a system will produce a design whose structure is a copy of the organization’s communication structure.”
    
-   **Architecture drift:** If team structures are left unchanged, architecture may solidify around silos, creating coupling and bottlenecks.
    
-   **Strategic architecture goals:** Modern systems often require microservices, domain-driven boundaries, or event-driven structures.
    
-   **Cultural inertia:** Teams naturally optimize for their local structure; changing team shape influences communication and thus the resulting system.
    
-   **Business agility:** To respond to markets, architecture must evolve — requiring deliberate organizational adaptation.
    

## Applicability

Use the Inverse Conway Maneuver when:

-   Architecture must move from monolith to microservices or modularization.
    
-   Domain-driven design (DDD) boundaries are identified, but teams are still organized around technical layers.
    
-   Teams are siloed (frontend vs backend, QA vs dev, ops vs dev) and this limits flow.
    
-   You want to scale delivery but avoid dependency hell.
    
-   Leadership wants to align organizational design with long-term business goals.
    

Do not apply when:

-   Architecture is already stable and aligned with team structures.
    
-   The organization lacks executive support for structural change.
    

## Structure

```scss
Business & Architecture Strategy
              │
              ▼
   ┌─────────────────────────┐
   │ Organizational Design   │
   │ (Inverse Conway Maneuver│
   │  defines team topology) │
   └──────────────┬──────────┘
                  │
                  ▼
   ┌─────────────────────────┐
   │     Team Structures     │
   │ (e.g., Stream-Aligned   │
   │  around bounded context │
   └──────────────┬──────────┘
                  │
                  ▼
   ┌─────────────────────────┐
   │ Software Architecture   │
   │ (aligned with domains,  │
   │ microservices, etc.)    │
   └─────────────────────────┘
```

## Participants

-   **Leadership / Architecture Owners:** Define target architecture vision (e.g., domain boundaries, modularity).
    
-   **Teams (Stream-Aligned, Feature Teams):** Realigned to match architecture goals.
    
-   **Enabling Teams:** Support transition by teaching new skills, practices.
    
-   **Platform Teams:** Provide common services that allow aligned teams to operate independently.
    
-   **HR/Org Design Units:** Enable structural change and role reassignments.
    

## Collaboration

-   Close collaboration between architects and organizational leaders to define new boundaries.
    
-   Continuous feedback loops between teams and architecture governance.
    
-   Workshops and mapping exercises (e.g., DDD context mapping, team topologies workshops).
    
-   Shared alignment artifacts: capability maps, domain maps, team interaction matrices.
    

## Consequences

**Benefits**

-   Architecture evolves in intended direction (modularity, scalability, independence).
    
-   Reduced coupling between teams → reduced coupling in software.
    
-   Increased delivery speed due to alignment of team and system boundaries.
    
-   Higher autonomy, fewer dependencies, clearer ownership.
    

**Liabilities / Trade-offs**

-   Requires disruptive organizational changes (reassignments, reporting line shifts).
    
-   Cultural resistance possible; teams may resist breaking long-standing silos.
    
-   Misalignment between business goals and team reshaping leads to wasted effort.
    
-   Transition period can reduce productivity temporarily.
    

## Implementation

1.  **Define Target Architecture**
    
    -   Identify business-aligned domains, bounded contexts, or desired modular structures.
        
    -   Use DDD, capability mapping, or architectural runway analysis.
        
2.  **Map Current Org to Current Architecture**
    
    -   Visualize communication structures (who talks to whom).
        
    -   Identify misalignments (e.g., separate frontend/backend teams working on the same feature).
        
3.  **Design Future Team Topology**
    
    -   Define stream-aligned teams around bounded contexts.
        
    -   Add supporting topologies (enabling, complicated subsystem, platform).
        
4.  **Transition Plan**
    
    -   Realign squads/teams gradually to avoid large-scale disruption.
        
    -   Pilot with one or two domains before scaling out.
        
5.  **Embed Feedback Loops**
    
    -   Measure architectural outcomes: coupling, deployment frequency, lead time.
        
    -   Adjust team structures as architecture evolves.
        
6.  **Cultural Enablement**
    
    -   Communicate clearly the “why” of restructuring.
        
    -   Offer training, guilds, or communities of practice for re-skilled roles.
        

## Sample Code (Java)

*Example of a modular structure a re-aligned team might own: one bounded context for “Orders” represented as an independent module/service. Teams are structured around such bounded contexts.*

```java
// A team aligned with the "Orders" bounded context owns this service.
// It is isolated from other domains and exposes a clear API.

package com.company.orders;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;

@RestController
@RequestMapping("/api/orders")
public class OrderController {

    private final OrderService service;

    public OrderController(OrderService service) {
        this.service = service;
    }

    @PostMapping
    public ResponseEntity<OrderDto> createOrder(@RequestBody OrderDto dto) {
        Order order = service.placeOrder(dto);
        return ResponseEntity.status(HttpStatus.CREATED).body(OrderDto.fromEntity(order));
    }

    @GetMapping("/{id}")
    public ResponseEntity<OrderDto> getOrder(@PathVariable Long id) {
        return service.findOrder(id)
                .map(o -> ResponseEntity.ok(OrderDto.fromEntity(o)))
                .orElse(ResponseEntity.notFound().build());
    }
}

@Service
class OrderService {
    private final OrderRepository repo;

    OrderService(OrderRepository repo) { this.repo = repo; }

    public Order placeOrder(OrderDto dto) {
        return repo.save(new Order(dto.getCustomerId(), dto.getProductId(), dto.getQuantity()));
    }

    public java.util.Optional<Order> findOrder(Long id) {
        return repo.findById(id);
    }
}

@Entity
@Table(name = "orders")
class Order {
    @Id @GeneratedValue
    private Long id;
    private Long customerId;
    private Long productId;
    private int quantity;

    protected Order() {}
    public Order(Long customerId, Long productId, int quantity) {
        this.customerId = customerId;
        this.productId = productId;
        this.quantity = quantity;
    }
    // getters omitted
}

record OrderDto(Long id, Long customerId, Long productId, int quantity) {
    static OrderDto fromEntity(Order o) {
        return new OrderDto(o.getId(), o.getCustomerId(), o.getProductId(), o.getQuantity());
    }
}

interface OrderRepository extends org.springframework.data.jpa.repository.JpaRepository<Order, Long> {}
```

**Why this helps:** By aligning a **team with the Orders bounded context**, ownership is clear, dependencies are reduced, and system modularity follows team communication lines.

## Known Uses

-   **Spotify:** Restructured squads around end-to-end product features instead of layers.
    
-   **Amazon:** “You build it, you run it” principle aligns teams to services they own.
    
-   **Microsoft Azure transformation:** Adopted team boundaries aligned with microservices.
    
-   **Volkswagen Group IT:** Used domain-driven re-alignment of teams for GRP services (case study in automotive IT).
    

## Related Patterns

-   **Conway’s Law:** The natural tendency the maneuver seeks to counteract.
    
-   **Stream-Aligned Team (Team Topologies):** A typical output of the Inverse Conway Maneuver.
    
-   **Feature Team:** Concrete example of restructured teams to own features end-to-end.
    
-   **Enabling Team:** Supports skill acquisition during re-alignment.
    
-   **Context Map (DDD):** Provides boundaries to align teams with architecture.
    
-   **Platform Team:** Ensures re-aligned teams can deliver independently.

You: 

Fill out the following chapters for the Organizational Team Pattern "Platform Team": Pattern Name and Classification, Intent, Also Known As, Motivation (Forces), Applicability, Structure, Participants, Collaboration, Consequences, Implementation, Sample Code, Known Uses, Related Patterns In case code is useful provide a sample code in Java. Start with the pattern name and topic as title. Proceed with the chapters as listed. Do not provide any questions in the end.

ChatGPT: 

# Platform Team — Organizational Team Pattern

## Pattern Name and Classification

**Name:** Platform Team  
**Classification:** Organizational Team Pattern — Enabling & Infrastructure-Support Team (Team Topologies)

## Intent

Provide internal teams with a **self-service platform** of reusable services, tools, and paved roads that reduce cognitive load and enable stream-aligned teams to deliver features faster, safer, and with higher quality.

## Also Known As

-   Internal Platform Engineering Team
    
-   Developer Experience (DevEx) Team
    
-   Infrastructure as a Product Team
    
-   Foundation Services Team
    

## Motivation (Forces)

-   **Cognitive load:** Stream-aligned/feature teams cannot manage infrastructure, CI/CD, monitoring, and business logic simultaneously.
    
-   **Consistency vs. autonomy:** Teams want autonomy in delivery, but organizations need consistency in deployment pipelines, observability, and security.
    
-   **Economies of scale:** Centralizing common concerns (logging, build pipelines, container orchestration) saves effort and prevents reinvention.
    
-   **Security & compliance:** Guardrails ensure teams meet regulatory and security requirements by default.
    
-   **Accelerated delivery:** A usable, reliable platform accelerates feature teams rather than blocking them.
    

## Applicability

Use a Platform Team when:

-   Multiple product/stream-aligned teams require common infrastructure and practices.
    
-   Duplicated effort (CI/CD pipelines, auth libraries, monitoring setup) is slowing down delivery.
    
-   The organization struggles with inconsistent environments or non-standardized practices.
    
-   You want to provide **“golden paths”** that balance freedom with best practices.
    

Avoid if:

-   The organization is too small (informal sharing may suffice).
    
-   Platform is treated as a ticket-based ops team instead of a product team.
    

## Structure

```arduino
┌─────────────────────────┐
                        │     Leadership / CTO     │
                        └───────────┬─────────────┘
                                    │
                                    ▼
                           ┌───────────────┐
                           │  Platform Team │
                           │ (builds tools, │
                           │ APIs, services)│
                           └───────┬────────┘
                                   │
      ┌────────────────────────────┼───────────────────────────┐
      │                            │                           │
┌─────▼─────┐              ┌───────▼───────┐            ┌──────▼───────┐
│ Stream-    │              │ Stream-       │            │ Stream-       │
│ Aligned    │              │ Aligned       │            │ Aligned       │
│ Team A     │              │ Team B        │            │ Team C        │
└────────────┘              └───────────────┘            └───────────────┘
```

-   Platform Team → provides reusable capabilities.
    
-   Stream-Aligned Teams → consume platform as self-service.
    

## Participants

-   **Platform Engineers:** Build and maintain platform services (CI/CD, Kubernetes, observability, auth).
    
-   **Product Manager (Platform):** Treats platform as a product, defines roadmap, measures adoption.
    
-   **UX for Developers:** Ensures platform is intuitive and usable.
    
-   **Stream-Aligned Teams:** Consumers of platform services; provide feedback.
    

## Collaboration

-   **Platform as a product:** Engage with stream-aligned teams as customers.
    
-   **Feedback loops:** Regular surveys, office hours, guilds for platform adoption.
    
-   **Documentation & onboarding:** Clear guides, templates, and paved roads.
    
-   **Shared governance:** Work with security, compliance, and architecture for built-in guardrails.
    

## Consequences

**Benefits**

-   Reduced cognitive load for feature teams.
    
-   Higher velocity and consistency across teams.
    
-   Secure, compliant, and observable systems by default.
    
-   Centralized cost optimization for infrastructure.
    

**Liabilities / Trade-offs**

-   Risk of becoming a **ticket factory Ops team** if not product-oriented.
    
-   Requires investment in developer experience and support.
    
-   Poorly designed platform → low adoption, shadow platforms emerge.
    
-   May inadvertently reduce autonomy if guardrails become constraints.
    

## Implementation

1.  **Adopt a Product Mindset**
    
    -   Define the platform as an internal product.
        
    -   Assign a product manager to prioritize features based on user needs.
        
2.  **Identify Common Needs**
    
    -   Build golden pipelines, service templates, observability frameworks.
        
    -   Provide SDKs/libraries for auth, monitoring, error handling.
        
3.  **Start Small, Iterate**
    
    -   Deliver a minimal viable platform service (e.g., CI/CD pipeline).
        
    -   Expand capabilities incrementally (logging, metrics, secrets management).
        
4.  **Developer-Centric UX**
    
    -   Provide self-service portals and CLIs.
        
    -   Focus on documentation and “paved roads.”
        
5.  **Measure Adoption & Outcomes**
    
    -   Metrics: Deployment frequency, cognitive load surveys, platform usage.
        
    -   Use adoption as success criteria, not just feature delivery.
        
6.  **Avoid Pitfalls**
    
    -   Don’t force adoption; incentivize via ease of use.
        
    -   Avoid building “ivory tower” platforms disconnected from users.
        

## Sample Code (Java)

*Example: Platform Team provides a reusable library for standardized service health checks, consumed by product teams to reduce cognitive load.*

```java
// Platform-provided library
package com.company.platform.health;

import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.HealthIndicator;

public class DatabaseHealthIndicator implements HealthIndicator {

    private final DatabaseClient dbClient;

    public DatabaseHealthIndicator(DatabaseClient dbClient) {
        this.dbClient = dbClient;
    }

    @Override
    public Health health() {
        try {
            dbClient.ping();
            return Health.up().withDetail("database", "reachable").build();
        } catch (Exception e) {
            return Health.down().withDetail("database", "unreachable").withException(e).build();
        }
    }
}

// Stream-aligned team consumes it in their service
package com.company.orders;

import com.company.platform.health.DatabaseHealthIndicator;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class HealthConfig {

    @Bean
    public DatabaseHealthIndicator dbHealth(DatabaseClient client) {
        return new DatabaseHealthIndicator(client);
    }
}
```

**Why this helps:**

-   Platform Team provides **reusable, standardized infrastructure code** (e.g., health indicators).
    
-   Stream-aligned teams integrate with minimal effort, focusing on business features instead of boilerplate.
    

## Known Uses

-   **Spotify:** Infrastructure squads evolved into platform teams to support squads with DevOps, CI/CD, and observability.
    
-   **Netflix:** Platform engineering teams provide tools like Spinnaker, Chaos Monkey, and paved roads.
    
-   **Google (SRE model):** SRE teams act as platform/product teams for reliability practices.
    
-   **Airbnb & Uber:** Developer productivity and platform engineering teams provide golden paths.
    

## Related Patterns

-   **Enabling Team:** Helps platform adoption but does not own long-term services.
    
-   **Stream-Aligned Team:** Primary consumer of platform services.
    
-   **Complicated Subsystem Team:** Specialized experts focusing on areas too complex for platform teams.
    
-   **Guilds and Chapters:** Share practices across teams, influencing platform features.
    
-   **Inverse Conway Maneuver:** Platform teams are often formed as part of aligning team structures with desired architecture.

You: 

Fill out the following chapters for the Organizational Team Pattern "Stream Aligned Team": Pattern Name and Classification, Intent, Also Known As, Motivation (Forces), Applicability, Structure, Participants, Collaboration, Consequences, Implementation, Sample Code, Known Uses, Related Patterns In case code is useful provide a sample code in Java. Start with the pattern name and topic as title. Proceed with the chapters as listed. Do not provide any questions in the end.

ChatGPT: 

# Stream-Aligned Team — Organizational Team Pattern

## Pattern Name and Classification

**Name:** Stream-Aligned Team  
**Classification:** Organizational Team Pattern — Delivery-Focused, End-to-End Team (Team Topologies)

## Intent

Align a team to a **continuous flow of work from a business domain or customer stream**, giving it end-to-end responsibility for delivery, operation, and improvement of its product or service. The team is long-lived, autonomous, and directly connected to business outcomes.

## Also Known As

-   Value Stream Team
    
-   Product Team
    
-   Feature Delivery Team (in some agile contexts)
    
-   Business-Aligned Delivery Team
    

## Motivation (Forces)

-   **Business alignment:** Teams aligned to technical layers or components require heavy coordination, slowing delivery.
    
-   **End-to-end ownership:** Having one team responsible for the whole lifecycle (build, run, improve) ensures accountability.
    
-   **Flow efficiency:** Work should flow continuously without frequent handoffs.
    
-   **Customer value delivery:** Alignment with a business stream ensures features are directly tied to customer needs.
    
-   **Team autonomy:** By reducing dependencies, teams can move faster and innovate more easily.
    

## Applicability

Use when:

-   The product or service can be **aligned to a specific value stream or customer journey** (e.g., “checkout,” “loyalty,” “vehicle contracts”).
    
-   End-to-end delivery requires multiple skills (frontend, backend, QA, UX, Ops).
    
-   Organization wants to scale using **multiple independent teams** instead of large siloed groups.
    
-   Agile/DevOps transformation requires teams to “build and run” what they own.
    

Avoid when:

-   The system requires deep, rare expertise only manageable in specialized teams (use Complicated Subsystem Teams).
    
-   Organization is too small to form stable, cross-functional teams.
    

## Structure

```arduino
┌──────────────────────────────┐
                   │       Business Value Stream   │
                   │ (e.g., Payments, Checkout)    │
                   └──────────────┬───────────────┘
                                  │
                         ┌────────▼────────┐
                         │ Stream-Aligned  │
                         │      Team       │
                         │ (cross-functional)  
                         └───────┬─────────┘
         ┌───────────────────────┼────────────────────────┐
         │                       │                        │
 ┌───────▼───────┐       ┌───────▼───────┐        ┌───────▼───────┐
 │  Frontend Dev │       │   Backend Dev │        │     QA/UX/DevOps│
 └───────────────┘       └───────────────┘        └────────────────┘
```

## Participants

-   **Product Owner / Product Manager:** Aligns work with business goals.
    
-   **Developers (Frontend, Backend, Mobile):** Deliver features across the stack.
    
-   **QA/Testers:** Ensure quality via automation and exploratory testing.
    
-   **UX/UI Designers:** Provide customer-centered design input.
    
-   **Ops/DevOps/SRE:** Enable deployment, observability, and reliability practices.
    
-   **Scrum Master / Agile Coach (optional):** Facilitate agile practices and team growth.
    

## Collaboration

-   Daily collaboration across disciplines within the team.
    
-   Direct collaboration with stakeholders and customers to refine backlog.
    
-   Shared ownership of code, pipeline, and operations.
    
-   Uses DevOps and agile practices (CI/CD, automated testing, monitoring).
    
-   Engages with Platform Teams and Enabling Teams for support.
    

## Consequences

**Benefits**

-   Direct link between business outcomes and team activities.
    
-   Faster delivery and shorter feedback loops.
    
-   Reduced coordination overhead.
    
-   Higher ownership and accountability.
    
-   Teams evolve with the product, building long-term knowledge.
    

**Liabilities / Trade-offs**

-   Requires broad skill coverage; risk of skill gaps.
    
-   Harder to maintain deep expertise in very specialized areas.
    
-   Requires investment in DevOps, CI/CD, and platform support to enable autonomy.
    
-   Potential duplication across multiple teams.
    

## Implementation

1.  **Identify Business Streams**
    
    -   Map customer journeys or domain boundaries (e.g., “checkout,” “order fulfillment”).
        
    -   Use Domain-Driven Design (DDD) bounded contexts as alignment anchors.
        
2.  **Form Teams**
    
    -   Create stable, cross-functional teams of 6–9 people.
        
    -   Ensure necessary skills are represented.
        
3.  **Define End-to-End Ownership**
    
    -   Team owns build, test, deploy, run, and monitor responsibilities.
        
    -   Provide “you build it, you run it” mandate.
        
4.  **Support Autonomy**
    
    -   Invest in platform engineering to reduce cognitive load.
        
    -   Use enabling teams for capability coaching.
        
5.  **Agile Delivery Practices**
    
    -   Backlog managed by product owner.
        
    -   Use Scrum, Kanban, or Lean practices.
        
    -   CI/CD pipelines owned and maintained by the team.
        
6.  **Measure Success**
    
    -   Lead time, deployment frequency, MTTR, and customer satisfaction.
        
    -   Business outcome metrics tied to stream (e.g., checkout conversion rate).
        

## Sample Code (Java)

*Example: A Stream-Aligned Team working on the “Checkout” value stream delivers an end-to-end feature, owning service, persistence, and integration.*

```java
// Stream-Aligned "Checkout" Team code
package com.company.checkout;

import org.springframework.web.bind.annotation.*;
import org.springframework.http.*;

@RestController
@RequestMapping("/api/checkout")
public class CheckoutController {

    private final CheckoutService service;

    public CheckoutController(CheckoutService service) {
        this.service = service;
    }

    @PostMapping
    public ResponseEntity<OrderReceipt> checkout(@RequestBody CheckoutRequest request) {
        OrderReceipt receipt = service.processCheckout(request);
        return ResponseEntity.status(HttpStatus.CREATED).body(receipt);
    }
}

// Service Layer
@Service
class CheckoutService {

    private final PaymentClient paymentClient;
    private final OrderRepository orderRepo;

    CheckoutService(PaymentClient paymentClient, OrderRepository orderRepo) {
        this.paymentClient = paymentClient;
        this.orderRepo = orderRepo;
    }

    public OrderReceipt processCheckout(CheckoutRequest req) {
        PaymentResult payment = paymentClient.charge(req.getPaymentInfo(), req.getTotalAmount());
        if (!payment.success()) {
            throw new IllegalStateException("Payment failed: " + payment.errorMessage());
        }
        Order order = orderRepo.save(new Order(req.getUserId(), req.getItems(), req.getTotalAmount()));
        return new OrderReceipt(order.getId(), "SUCCESS");
    }
}

// Entity
@Entity
@Table(name = "orders")
class Order {
    @Id @GeneratedValue
    private Long id;
    private Long userId;
    private double totalAmount;

    protected Order() {}
    public Order(Long userId, java.util.List<String> items, double totalAmount) {
        this.userId = userId;
        this.totalAmount = totalAmount;
    }
    // getters
}

// Repository
interface OrderRepository extends org.springframework.data.jpa.repository.JpaRepository<Order, Long> { }

// DTOs
record CheckoutRequest(Long userId, java.util.List<String> items, PaymentInfo paymentInfo, double totalAmount) {}
record PaymentInfo(String cardNumber, String expiry, String cvv) {}
record PaymentResult(boolean success, String errorMessage) {}
record OrderReceipt(Long orderId, String status) {}

// External payment integration (owned by same team or stubbed)
interface PaymentClient {
    PaymentResult charge(PaymentInfo info, double amount);
}
```

**Why this helps:**

-   Team owns **Checkout domain** end-to-end: API, persistence, payment integration.
    
-   No need for separate frontend/backend/ops silos.
    
-   Reduces dependencies, accelerates delivery.
    

## Known Uses

-   **Spotify Squads:** Stream-aligned to product areas (e.g., playlists, payments).
    
-   **Amazon “Two-Pizza Teams”:** End-to-end teams aligned to services.
    
-   **ING Bank Agile Transformation:** Stream-aligned squads mapped to customer journeys.
    
-   **Volkswagen Group Retail IT:** Stream teams aligned with business domains like “agreements,” “market areas,” etc.
    

## Related Patterns

-   **Feature Team:** Similar in end-to-end responsibility, but Stream-Aligned Teams are explicitly aligned to a business value stream.
    
-   **Platform Team:** Supports stream-aligned teams with reusable services.
    
-   **Enabling Team:** Helps stream-aligned teams adopt new practices.
    
-   **Complicated Subsystem Team:** Provides expertise when complexity exceeds the skillset of stream-aligned teams.
    
-   **Inverse Conway Maneuver:** Used to structure organizations into stream-aligned teams.
    
-   **Context Map (DDD):** Provides boundaries that stream-aligned teams align with.

You: 

Fill out the following chapters for the Refactoring Pattern "Consolidate Duplicate Code": Pattern Name and Classification, Intent, Also Known As, Motivation (Forces), Applicability, Structure, Participants, Collaboration, Consequences, Implementation, Sample Code, Known Uses, Related Patterns In case code is useful provide a sample code in Java. Start with the pattern name and topic as title. Proceed with the chapters as listed. Do not provide any questions in the end.

ChatGPT: 

Nachgedacht für 5s

# Consolidate Duplicate Code — Refactoring Pattern

## Pattern Name and Classification

**Name:** Consolidate Duplicate Code  
**Classification:** Refactoring Pattern (Code Smell Remediation / DRY Enforcement)

## Intent

Eliminate copy-pasted or near-duplicate logic by extracting it into a single, well-named abstraction (function, class, module, or template) so behavior lives in exactly one place, reducing defects and maintenance cost.

## Also Known As

-   DRY (Don’t Repeat Yourself)
    
-   Extract Method/Class/Module
    
-   Unify Algorithms / Pull Up Method (OO hierarchies)
    
-   Replace Conditional with Polymorphism (when duplicates come from branching)
    

## Motivation (Forces)

-   **Readability vs. speed:** Copy-paste is fast now but expensive later.
    
-   **Divergence risk:** Bug fixes land in one copy and not the others.
    
-   **Cognitive load:** Multiple places to understand before safely changing behavior.
    
-   **Coupling constraints:** Teams duplicate code to avoid awkward dependencies or poor module boundaries.
    
-   **Performance & correctness:** Inconsistent implementations (e.g., rounding, time zones) subtly diverge.
    

## Applicability

Apply when you find:

-   **Exact duplicates** across modules, services, or layers.
    
-   **Near duplicates** with minor parameter differences or superficial variations.
    
-   **Parallel inheritance hierarchies** with identical methods.
    
-   **Repetitive setup/teardown** logic in tests or pipelines.
    
-   **Repeated algorithms** (e.g., tax, currency, pagination, retry logic, validation).
    

Avoid or postpone when:

-   The duplicates are **intentionally divergent** for latency, compliance, or rollout safety.
    
-   The shared dependency would **introduce an undesirable coupling**; first fix the boundary (e.g., via an internal library or service).
    

## Structure

```css
Before:                           After:
A.foo()  ──┐                      A.foo() ─┐
B.foo()  ──┤  (duplicate)   ──►   B.foo()  ├──► Shared Abstraction (Function/Class/Module/Service)
C.foo()  ──┘                      C.foo() ─┘
```

## Participants

-   **Callers:** Components currently hosting duplicate logic.
    
-   **Shared Abstraction:** The new single source of truth (utility function, domain service, base class, strategy).
    
-   **Tests:** Executable specification that locks in behavior and prevents regression.
    
-   **Build/Repo Owners:** Ensure the shared abstraction is accessible (module, package, service).
    

## Collaboration

-   Identify duplicates with tooling (clone detectors, PMD/SpotBugs, IDE inspections) and code reviews.
    
-   Agree on **ownership** of the extracted abstraction (team, repo, versioning).
    
-   Provide a **migration plan** for consumers (deprecation window, semantic versioning).
    
-   Use **feature flags** or shadow calls if consolidating behavior with production risk.
    

## Consequences

**Benefits**

-   Single place to fix bugs and evolve logic.
    
-   Smaller codebase; lower cognitive load.
    
-   Consistent behavior across the system; easier onboarding.
    

**Liabilities / Trade-offs**

-   Introduces a new dependency surface; potential coupling.
    
-   If designed too generically, may become **anemic “god” utility** or leaky abstraction.
    
-   Migration effort and short-term churn (PRs across many repos).
    

## Implementation

1.  **Find & Cluster Duplicates**
    
    -   Use tooling + grep + code review. Group by intent (e.g., “discount calc”, “JWT parsing”).
        
2.  **Lock Behavior with Tests**
    
    -   Golden-master or approval tests for each duplicate to capture current quirks.
        
3.  **Design the Abstraction**
    
    -   Prefer **simple function** first; escalate to class/strategy only if needed.
        
    -   Keep domain language; avoid “Utils” unless truly generic.
        
4.  **Extract & Inline**
    
    -   Create the shared API; switch one caller at a time; run tests; repeat.
        
5.  **Remove Dead Code**
    
    -   Delete old implementations; add deprecation notices until fully migrated.
        
6.  **Publish & Govern**
    
    -   Version the library; document usage; add CI checks to prevent regressions and re-duplication (e.g., clone-detection in CI).
        

## Sample Code (Java)

### Before (duplication across services)

```java
// In BillingService
public BigDecimal computeDiscount(BigDecimal subtotal, CustomerTier tier) {
  BigDecimal rate = switch (tier) {
    case GOLD -> new BigDecimal("0.15");
    case SILVER -> new BigDecimal("0.10");
    default -> BigDecimal.ZERO;
  };
  BigDecimal discounted = subtotal.multiply(BigDecimal.ONE.subtract(rate));
  return discounted.setScale(2, RoundingMode.HALF_UP);
}

// In PromotionService (nearly identical, different rounding)
public BigDecimal applyPromo(BigDecimal subtotal, CustomerTier tier) {
  BigDecimal rate = switch (tier) {
    case GOLD -> new BigDecimal("0.15");
    case SILVER -> new BigDecimal("0.10");
    default -> BigDecimal.ZERO;
  };
  BigDecimal discounted = subtotal.multiply(BigDecimal.ONE.subtract(rate));
  return discounted.setScale(2, RoundingMode.HALF_EVEN); // subtle divergence!
}
```

### After (consolidated abstraction with strategy hook)

```java
// Shared library: domain-oriented, not "Util"
package com.acme.pricing;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Objects;

public final class DiscountCalculator {

  public enum RoundingPolicy {
    RETAIL(RoundingMode.HALF_UP),
    FINANCE(RoundingMode.HALF_EVEN);
    final RoundingMode mode;
    RoundingPolicy(RoundingMode mode){ this.mode = mode; }
  }

  private final RoundingPolicy roundingPolicy;

  private DiscountCalculator(RoundingPolicy roundingPolicy) {
    this.roundingPolicy = Objects.requireNonNull(roundingPolicy);
  }

  public static DiscountCalculator retail()  { return new DiscountCalculator(RoundingPolicy.RETAIL); }
  public static DiscountCalculator finance() { return new DiscountCalculator(RoundingPolicy.FINANCE); }

  public BigDecimal priceAfterDiscount(BigDecimal subtotal, CustomerTier tier) {
    Objects.requireNonNull(subtotal); Objects.requireNonNull(tier);
    BigDecimal rate = switch (tier) {
      case GOLD -> new BigDecimal("0.15");
      case SILVER -> new BigDecimal("0.10");
      default -> BigDecimal.ZERO;
    };
    BigDecimal discounted = subtotal.multiply(BigDecimal.ONE.subtract(rate));
    return discounted.setScale(2, roundingPolicy.mode);
  }

  public enum CustomerTier { GOLD, SILVER, STANDARD }
}
```

```java
// BillingService uses the shared abstraction
import com.acme.pricing.DiscountCalculator;
import com.acme.pricing.DiscountCalculator.CustomerTier;

public class BillingService {
  private final DiscountCalculator calc = DiscountCalculator.retail();

  public Amount bill(Amount subtotal, CustomerTier tier) {
    var after = calc.priceAfterDiscount(subtotal.value(), tier);
    return new Amount(after);
  }
}

// PromotionService uses the same abstraction with a different policy if required
import com.acme.pricing.DiscountCalculator;
import com.acme.pricing.DiscountCalculator.CustomerTier;

public class PromotionService {
  private final DiscountCalculator calc = DiscountCalculator.finance();

  public Amount apply(Amount subtotal, CustomerTier tier) {
    var after = calc.priceAfterDiscount(subtotal.value(), tier);
    return new Amount(after);
  }
}

// Tiny value object
import java.math.BigDecimal;
public record Amount(BigDecimal value) {}
```

### Test (golden-master behavior preserved)

```java
class DiscountCalculatorTest {
  @org.junit.jupiter.api.Test
  void retailRoundingMatchesLegacy() {
    var calc = DiscountCalculator.retail();
    var out = calc.priceAfterDiscount(new BigDecimal("123.456"), DiscountCalculator.CustomerTier.GOLD);
    org.assertj.core.api.Assertions.assertThat(out.toPlainString()).isEqualTo("104.94");
  }
}
```

## Known Uses

-   Consolidation of **date/time** and **money** handling into shared libraries to avoid locale/rounding bugs.
    
-   Centralized **HTTP client wrappers** with retries/timeouts/trace propagation.
    
-   Unifying **validation** (email, VAT, IBAN) rules across services.
    
-   Replacing duplicated **SQL pagination** or **cursor** logic with a common repository helper.
    
-   Pull Up Method in OO hierarchies where subclasses repeated identical logic.
    

## Related Patterns

-   **Extract Method / Extract Class:** Micro-refactorings used to consolidate.
    
-   **Pull Up Method / Template Method / Strategy:** OO techniques to remove duplication across classes.
    
-   **Replace Conditional with Polymorphism:** When duplication stems from branching on types.
    
-   **Introduce Parameter Object:** When duplicates differ only in long parameter lists.
    
-   **Move Method / Move Field:** Align behavior with owning class to reduce scattered copies.
    
-   **Facade:** Expose a unified API to replace repeated integration glue.

You: 

Fill out the following chapters for the Refactoring Pattern "Decompose Conditional": Pattern Name and Classification, Intent, Also Known As, Motivation (Forces), Applicability, Structure, Participants, Collaboration, Consequences, Implementation, Sample Code, Known Uses, Related Patterns In case code is useful provide a sample code in Java. Start with the pattern name and topic as title. Proceed with the chapters as listed. Do not provide any questions in the end.

ChatGPT: 

Nachgedacht für 5s

# Decompose Conditional — Refactoring Pattern

## Pattern Name and Classification

**Name:** Decompose Conditional  
**Classification:** Refactoring Pattern (Control Flow Simplification / Readability & Maintainability)

## Intent

Improve readability and maintainability by **extracting complex conditional logic** (long `if/else` or `switch` statements with compound predicates and mixed responsibilities) into **well-named methods, guard clauses, and dedicated strategies** so that the branching intent becomes explicit and testable.

## Also Known As

-   Split Conditional
    
-   Extract Condition / Extract Branch
    
-   Guard Clauses
    
-   Replace Conditional with Strategy (when pushing to polymorphism)
    

## Motivation (Forces)

-   **Mixed concerns:** Condition checks, data gathering, and effects are interleaved.
    
-   **Cognitive load:** Large boolean expressions obscure business intent.
    
-   **Change risk:** Subtle edits to predicates cause bugs (e.g., precedence, null handling).
    
-   **Limited testability:** Hard to test tiny variations inside a monolithic conditional.
    
-   **Evolving rules:** Business rules accumulate exceptions that elongate branching.
    

## Applicability

Apply when you see:

-   Compound predicates like `if (a && (b || c) && !d)` mingled with side effects.
    
-   Repeated *similar* condition groups across the codebase.
    
-   Condition blocks performing **multiple responsibilities** (validation, pricing, authorization).
    
-   Long `switch`/`if-else if-else` chains driven by a domain concept (“product type”, “tier”, “status”).
    

Avoid or defer when:

-   The conditional is tiny, obvious, and will not grow.
    
-   Performance-critical hot paths where extra calls would be measurable (rare; can still inline after clarity).
    

## Structure

```kotlin
Before:
+-----------------------------------------+
| method()                                |
|   if (complex && (nested || chains)) {  |
|     // do A + B + C                     |
|   } else if (...) {                      |
|     // do D                             |
|   } else {                               |
|     // do E                             |
|   }                                      |
+-----------------------------------------+

After (decomposed):
+-----------------------------------------+
| method()                                |
|   if (isExceptional()) return handleX();|
|   if (isEligible())     return doEligiblePath(); 
|   return doDefaultPath();               |
+-----------------------------------------+
            |                |
      predicate methods   extracted actions
            |
   (or) Strategy/Policy object selected by context
```

## Participants

-   **Caller / Orchestrator:** High-level method that reads like a decision narrative.
    
-   **Predicate Methods:** Small, pure functions expressing intent (e.g., `isVipCustomer`, `isBlackoutPeriod`).
    
-   **Action Methods / Strategies:** Encapsulate branch behavior (e.g., `applyVipDiscount`, `denyBooking`).
    
-   **Policy/Strategy Objects (optional):** When branching follows a stable axis (type/status).
    

## Collaboration

-   Predicates expose *business vocabulary*; actions encapsulate side effects.
    
-   Orchestrator composes predicates and actions using **guard clauses** (fail/return early).
    
-   Strategies can be composed/injected for testability; predicates are unit-tested in isolation.
    

## Consequences

**Benefits**

-   Readable “story” in the orchestrator; easier onboarding.
    
-   Localized changes: modify a predicate or strategy without touching the others.
    
-   Higher testability and reuse of predicates across features.
    
-   Enables further refactorings (Strategy, Specification, Rule Engine) if rules grow.
    

**Liabilities / Trade-offs**

-   More methods/classes; slight indirection overhead.
    
-   Poorly named predicates can *increase* confusion—naming matters.
    
-   Over-engineering risk if rules are simple or transient.
    

## Implementation

1.  **Identify the Decision Points**
    
    -   Mark complex boolean expressions and long chains.
        
2.  **Extract Predicates**
    
    -   Create small, side-effect-free methods with domain names.
        
    -   Normalize null/empty checks inside predicates.
        
3.  **Introduce Guard Clauses**
    
    -   Replace nested `if`s with early returns for exceptional/fast-fail cases.
        
4.  **Extract Branch Actions**
    
    -   Pull effectful code into intention-revealing methods.
        
5.  **Consider Strategy/Policy**
    
    -   If branching is driven by one axis (type/status/tier), create a `Map<Axis, Strategy>`.
        
6.  **Add Tests**
    
    -   Unit-test predicates and actions independently; keep an integration test for the orchestrator.
        
7.  **Simplify and Inline Where Appropriate**
    
    -   If a predicate becomes trivial, you may inline it—but keep clarity.
        
8.  **Document Invariants**
    
    -   Javadoc/preconditions clarify assumptions (currency, time zone, permissions).
        

## Sample Code (Java)

### Before — Tangled Conditional

```java
public class FareService {

  public BigDecimal calculateFare(Trip trip, Customer customer, LocalDate date) {
    // giant, intertwined conditional logic
    if (trip == null || customer == null || date == null) {
      throw new IllegalArgumentException("missing data");
    }

    boolean peak = (date.getDayOfWeek().getValue() >= 1 && date.getDayOfWeek().getValue() <= 5)
        && (trip.getDepartureTime().getHour() >= 7 && trip.getDepartureTime().getHour() <= 9
        || trip.getDepartureTime().getHour() >= 16 && trip.getDepartureTime().getHour() <= 18);

    BigDecimal base = trip.getBaseFare();
    if (customer.isBlacklisted()) {
      return base.multiply(new BigDecimal("2.00")); // punitive
    } else if (customer.isVip() && !peak && trip.getDistanceKm() > 10) {
      BigDecimal d = base.multiply(new BigDecimal("0.85"));
      if (trip.isEcoVehicle()) {
        d = d.multiply(new BigDecimal("0.98"));
      }
      return d.setScale(2, RoundingMode.HALF_EVEN);
    } else if (peak && trip.getDistanceKm() < 3) {
      return base.add(new BigDecimal("2.50")).setScale(2, RoundingMode.HALF_EVEN);
    } else {
      return base.setScale(2, RoundingMode.HALF_EVEN);
    }
  }
}
```

### After — Decomposed with Predicates, Guard Clauses, and Strategy Hook

```java
public class FareService {

  private final RoundingMode rounding = RoundingMode.HALF_EVEN;

  public BigDecimal calculateFare(Trip trip, Customer customer, LocalDate date) {
    requireArgs(trip, customer, date);

    if (isPunitiveCase(customer)) {
      return punitiveFare(trip.getBaseFare());
    }
    if (isVipOffPeakLongTrip(customer, date, trip)) {
      return vipFare(trip);
    }
    if (isShortTripAtPeak(date, trip)) {
      return shortPeakFare(trip.getBaseFare());
    }
    return standardFare(trip.getBaseFare());
  }

  // ----- Predicates -----
  boolean isPunitiveCase(Customer c) { return c.isBlacklisted(); }

  boolean isVipOffPeakLongTrip(Customer c, LocalDate d, Trip t) {
    return c.isVip() && !isPeak(d, t) && t.getDistanceKm() > 10;
  }

  boolean isShortTripAtPeak(LocalDate d, Trip t) {
    return isPeak(d, t) && t.getDistanceKm() < 3;
  }

  boolean isPeak(LocalDate d, Trip t) {
    int dow = d.getDayOfWeek().getValue(); // 1=Mon..7=Sun
    int hour = t.getDepartureTime().getHour();
    boolean weekday = dow >= 1 && dow <= 5;
    boolean morning = hour >= 7 && hour <= 9;
    boolean evening = hour >= 16 && hour <= 18;
    return weekday && (morning || evening);
  }

  // ----- Actions -----
  BigDecimal punitiveFare(BigDecimal base) {
    return base.multiply(new BigDecimal("2.00")).setScale(2, rounding);
  }

  BigDecimal vipFare(Trip t) {
    BigDecimal d = t.getBaseFare().multiply(new BigDecimal("0.85"));
    if (t.isEcoVehicle()) d = d.multiply(new BigDecimal("0.98"));
    return d.setScale(2, rounding);
  }

  BigDecimal shortPeakFare(BigDecimal base) {
    return base.add(new BigDecimal("2.50")).setScale(2, rounding);
  }

  BigDecimal standardFare(BigDecimal base) {
    return base.setScale(2, rounding);
  }

  void requireArgs(Trip trip, Customer customer, LocalDate date) {
    if (trip == null || customer == null || date == null) {
      throw new IllegalArgumentException("missing data");
    }
  }
}
```

### Variant — Replace Conditional with Strategy (when axis is stable)

```java
public interface FarePolicy {
  BigDecimal price(Trip trip, Customer customer, LocalDate date);
}

public class PeakShortTripPolicy implements FarePolicy { /* ... */ }
public class VipOffPeakLongTripPolicy implements FarePolicy { /* ... */ }
public class PunitivePolicy implements FarePolicy { /* ... */ }
public class StandardPolicy implements FarePolicy { /* ... */ }

public class FareEngine {
  private final List<FarePolicy> policies;

  public FareEngine(List<FarePolicy> policies) { this.policies = List.copyOf(policies); }

  public BigDecimal calculate(Trip t, Customer c, LocalDate d) {
    return policies.stream()
        .map(p -> p.price(t, c, d))
        .filter(Objects::nonNull)
        .findFirst()
        .orElseThrow(); // or default
  }
}
```

## Known Uses

-   **Pricing/Discount engines:** Extracting predicates like `isBlackFriday`, `isVip`, `isBundleEligible`.
    
-   **Authorization/Feature flags:** Guard clauses and policy objects per permission/flag.
    
-   **Validation pipelines:** Predicates per constraint (Specification pattern).
    
-   **Workflow routing:** Strategy selection by status/type to avoid `switch` bloat.
    
-   **Legacy monoliths:** First step before migrating rules to a rules engine.
    

## Related Patterns

-   **Extract Method / Extract Function:** Primary micro-refactoring used here.
    
-   **Guard Clauses:** Early returns replacing deep nesting.
    
-   **Replace Conditional with Polymorphism (Strategy/State):** When branching follows a stable axis.
    
-   **Specification Pattern:** Compose business predicates declaratively.
    
-   **Consolidate Duplicate Conditional Fragments:** Remove repeated setup inside branches.
    
-   **Decompose Switch:** Special case targeting large `switch` statements.
    
-   **Introduce Parameter Object:** Simplify long parameter lists that feed predicates.

You: 

Fill out the following chapters for the Refactoring Pattern "Encapsulate Field": Pattern Name and Classification, Intent, Also Known As, Motivation (Forces), Applicability, Structure, Participants, Collaboration, Consequences, Implementation, Sample Code, Known Uses, Related Patterns In case code is useful provide a sample code in Java. Start with the pattern name and topic as title. Proceed with the chapters as listed. Do not provide any questions in the end.

ChatGPT: 

# Encapsulate Field — Refactoring Pattern

## Pattern Name and Classification

**Name:** Encapsulate Field  
**Classification:** Refactoring Pattern (Information Hiding / Data Integrity)

## Intent

Prevent external code from directly reading or writing object state by **hiding fields behind accessors** (getters/setters or specialized methods). This enables validation, invariants, lazy computation, thread safety, notifications, and future evolution without breaking callers.

## Also Known As

-   Hide Field
    
-   Accessor Methods
    
-   Information Hiding (Parnas)
    
-   Data Hiding
    

## Motivation (Forces)

-   **Invariants & validation:** Direct writes can violate constraints (e.g., negative prices, invalid states).
    
-   **Binary compatibility:** Public fields lock ABI; accessors allow evolution (derived values, caching, logging).
    
-   **Thread safety:** Coordinated access (synchronization, atomics) is impossible with public fields.
    
-   **Observability:** Need to trigger side effects (events, dirty flags) when state changes.
    
-   **API clarity:** Distinguish *intention-revealing* operations from raw mutation.
    

## Applicability

Apply when:

-   Classes expose `public` or `package-private` fields used by external code.
    
-   Invariants are implicit or repeatedly checked at call sites.
    
-   You need to add validation, lazy init, caching, or notify observers on change.
    
-   Collections are exposed directly (risk of uncontrolled mutation).
    

Avoid or defer when:

-   You’re in a **data-only DTO boundary** specifically intended for serialization with clear stability guarantees (still prefer records).
    
-   Performance-critical hot paths where accessor overhead matters (rare; consider `final` + records/immutability).
    

## Structure

```csharp
Before:                          After:
+---------------------+          +---------------------+
|  public int age;    |   --->   |  private int age;   |
|                     |          |  public int age(){  |
|                     |          |    return age; }    |
|                     |          |  public void setAge(int v){ 
|                     |          |    require(v>=0);   |
|                     |          |    this.age=v; }    |
+---------------------+          +---------------------+
```

## Participants

-   **Field Owner (Class):** Declares private state and enforces invariants.
    
-   **Accessors / Mutators:** Methods that reveal intent (e.g., `renameTo`, `increaseStockBy`), not just generic setters.
    
-   **Clients:** Use accessors; no direct state manipulation.
    
-   **Observers / Domain Events (optional):** React to state changes.
    

## Collaboration

-   Clients call **queries** (getters) and **commands** (setters/intent methods).
    
-   The class centralizes validation, logging, and notifications.
    
-   If multiple fields change together, provide aggregate operations to preserve invariants.
    

## Consequences

**Benefits**

-   Preserves invariants and integrity; easier debugging and logging.
    
-   Allows internal representation changes without breaking API.
    
-   Enables thread-safety, caching, lazy loading, and events.
    
-   Prevents representation exposure (defensive copies for collections).
    

**Liabilities / Trade-offs**

-   Slight verbosity and indirection.
    
-   Poorly named generic setters can hide domain intent.
    
-   Over-encapsulation can complicate simple data transfer scenarios.
    

## Implementation

1.  **Change Field Visibility** to `private` (or least possible).
    
2.  **Add Accessors**: start with getters; replace writes with set/command methods.
    
3.  **Enforce Invariants** inside mutators (validation, normalization).
    
4.  **Prefer Intent-Revealing Methods** (`renameTo`, `deactivate`, `increaseBy`) over raw `setX`.
    
5.  **Defensive Copies** for mutable aggregates (e.g., `List`, `Date`). Return unmodifiable views.
    
6.  **Thread Safety** if needed (synchronization/atomics).
    
7.  **Deprecate and Migrate**: replace direct field references gradually; keep backward compatibility where required.
    
8.  **Tests**: add unit tests for invariants and side effects.
    

## Sample Code (Java)

### 1) Before → After (simple validation and intent-revealing operations)

```java
// Before
public class Product {
  public String name;
  public BigDecimal price;
}

// After
public class Product {
  private String name;
  private BigDecimal price;

  public Product(String name, BigDecimal price) {
    renameTo(name);
    changePriceTo(price);
  }

  public String name() { return name; }
  public BigDecimal price() { return price; }

  /** Intent-revealing command with validation */
  public void renameTo(String newName) {
    if (newName == null || newName.isBlank()) {
      throw new IllegalArgumentException("name must not be blank");
    }
    this.name = newName.strip();
  }

  /** Centralized invariant enforcement */
  public void changePriceTo(BigDecimal newPrice) {
    if (newPrice == null || newPrice.signum() < 0) {
      throw new IllegalArgumentException("price must be >= 0");
    }
    this.price = newPrice.setScale(2, java.math.RoundingMode.HALF_EVEN);
  }
}
```

### 2) Encapsulate a collection (defensive copies and unmodifiable view)

```java
public class Order {
  private final List<OrderLine> lines = new ArrayList<>();

  /** Query returns an unmodifiable view to avoid representation exposure */
  public List<OrderLine> lines() {
    return java.util.Collections.unmodifiableList(lines);
  }

  /** Intent-revealing command ensures invariants per addition */
  public void addLine(OrderLine line) {
    Objects.requireNonNull(line, "line");
    if (line.quantity() <= 0) throw new IllegalArgumentException("qty > 0");
    this.lines.add(line);
  }

  /** Aggregate update preserves invariants atomically */
  public void replaceLines(List<OrderLine> newLines) {
    Objects.requireNonNull(newLines, "newLines");
    if (newLines.stream().anyMatch(l -> l.quantity() <= 0))
      throw new IllegalArgumentException("all qty > 0");
    this.lines.clear();
    this.lines.addAll(new ArrayList<>(newLines)); // defensive copy
  }
}
```

### 3) Thread-safe field encapsulation with `AtomicReference`

```java
public class FeatureFlag {
  private final java.util.concurrent.atomic.AtomicReference<Boolean> enabled =
      new java.util.concurrent.atomic.AtomicReference<>(false);

  public boolean isEnabled() { return enabled.get(); }

  public void enable()  { enabled.set(true); }
  public void disable() { enabled.set(false); }

  /** CAS style for racing updates */
  public boolean compareAndSet(boolean expect, boolean update) {
    return enabled.compareAndSet(expect, update);
  }
}
```

### 4) Domain events on mutation (observability hook)

```java
public class Account {
  private BigDecimal balance = BigDecimal.ZERO;
  private final List<Consumer<BigDecimal>> listeners = new ArrayList<>();

  public BigDecimal balance() { return balance; }

  public void deposit(BigDecimal amount) {
    requirePositive(amount);
    var old = balance;
    balance = balance.add(amount);
    notifyChanged(old, balance);
  }

  public void withdraw(BigDecimal amount) {
    requirePositive(amount);
    if (balance.compareTo(amount) < 0) throw new IllegalStateException("insufficient funds");
    var old = balance;
    balance = balance.subtract(amount);
    notifyChanged(old, balance);
  }

  public void onBalanceChanged(Consumer<BigDecimal> listener) { listeners.add(listener); }

  private void requirePositive(BigDecimal v) {
    if (v == null || v.signum() <= 0) throw new IllegalArgumentException("amount > 0");
  }

  private void notifyChanged(BigDecimal oldVal, BigDecimal newVal) {
    listeners.forEach(l -> l.accept(newVal));
  }
}
```

### 5) Immutability as a stronger form of encapsulation (Java Record)

```java
public record Money(BigDecimal amount, String currency) {
  public Money {
    Objects.requireNonNull(amount); Objects.requireNonNull(currency);
    if (amount.signum() < 0) throw new IllegalArgumentException("amount >= 0");
  }
  public Money add(Money other) {
    if (!currency.equals(other.currency())) throw new IllegalArgumentException("currency mismatch");
    return new Money(amount.add(other.amount()), currency);
  }
}
```

## Known Uses

-   Replacing `public` fields in legacy POJOs with accessors to add validation and logging.
    
-   Wrapping configuration flags in accessors to support dynamic reload and audit.
    
-   Encapsulating mutable collections in domain models to prevent accidental external mutation.
    
-   Migrating DTOs to **records** or immutable value objects for safer APIs.
    
-   Introducing domain events/observers where changes must be tracked (audit trails).
    

## Related Patterns

-   **Encapsulate Collection:** Specialized variant focusing on aggregates.
    
-   **Introduce Parameter Object / Value Object:** Strengthen invariants and readability.
    
-   **Replace Data Value with Object:** Turn primitive fields into rich types.
    
-   **Immutable Object:** Maximize safety by eliminating setters.
    
-   **Move Method / Move Field:** Align behavior with its true owner.
    
-   **Observer / Domain Event:** React to encapsulated state changes.

You: 

Fill out the following chapters for the Refactoring Pattern "Extract Class": Pattern Name and Classification, Intent, Also Known As, Motivation (Forces), Applicability, Structure, Participants, Collaboration, Consequences, Implementation, Sample Code, Known Uses, Related Patterns In case code is useful provide a sample code in Java. Start with the pattern name and topic as title. Proceed with the chapters as listed. Do not provide any questions in the end.

ChatGPT: 

# Extract Class — Refactoring Pattern

## Pattern Name and Classification

**Name:** Extract Class  
**Classification:** Refactoring Pattern (Divide-and-Conquer / Separation of Concerns)

## Intent

Split a **bloated class** that holds multiple responsibilities into **two (or more) cohesive classes**, each with a clear purpose and API. This reduces coupling, improves readability/testability, and unlocks independent evolution.

## Also Known As

-   Class Decomposition
    
-   Separate Responsibilities
    
-   Cohesion Increase
    

## Motivation (Forces)

-   **Feature envy & shotgun surgery:** Unrelated changes require touching one god class.
    
-   **Low cohesion, high cognitive load:** Fields and methods cluster into distinct concerns.
    
-   **Testing friction:** Hard to isolate behaviors (e.g., shipping rules vs. order math).
    
-   **Growth pressure:** Adding features to an already huge class increases risk.
    
-   **API clarity:** Consumers can depend on the subset they actually need.
    

## Applicability

Apply when you see:

-   A class with **\>300–500 LOC**, many fields, or long method list.
    
-   Methods and fields forming **natural clusters** (e.g., “address/contacts,” “pricing/discounts,” “IO/persistence”).
    
-   Multiple **reasons to change** (violates Single Responsibility Principle).
    
-   Repeated parameter groups hinting at a missing abstraction.
    

Avoid or defer when:

-   The class is a **small, stable value object**.
    
-   Splitting would create **anemic, chatty objects** with high call overhead without real cohesion gain.
    

## Structure

```pgsql
Before (God Class):
+------------------------------+
| Order                        |
| - id                         |
| - items, totals              |
| - customer fields            |
| - address parsing/validation |
| - shipping price rules       |
| - payment/credit checks      |
| - printing/export            |
+------------------------------+

After (Extracted Classes):
+------------+     uses      +-------------------+
| Order      |-------------->| ShippingPolicy    |
| (domain)   |               | (rates & rules)   |
+------------+               +-------------------+
        |
        | has-a
        v
+----------------+
| PostalAddress  |
| (value object) |
+----------------+
```

## Participants

-   **Original Class:** The bloated owner of mixed concerns.
    
-   **Extracted Class(es):** New cohesive abstractions (e.g., `ShippingPolicy`, `PostalAddress`).
    
-   **Clients:** Callers that now depend on a smaller, clearer surface.
    
-   **Tests:** Guard behavior during extraction and prevent regressions.
    

## Collaboration

-   The original class **delegates** to the extracted class.
    
-   Extracted class exposes **intention-revealing methods**; data sharing via constructor/setters or dedicated DTOs/VOs.
    
-   Prefer **one-way dependencies** (domain → policy), avoiding cycles.
    

## Consequences

**Benefits**

-   Higher cohesion, smaller surface area, simpler tests.
    
-   Independent evolution and reuse of extracted parts.
    
-   Clearer ownership and boundaries; easier onboarding.
    

**Liabilities / Trade-offs**

-   Short-term churn (moving code, updating imports).
    
-   Potential **chatty interfaces** if boundaries are wrong.
    
-   Might reveal the need for **further refactorings** (e.g., Extract Interface, Move Method).
    

## Implementation

1.  **Identify Responsibility Clusters**
    
    -   Group fields/methods by topic (e.g., shipping rules, address handling).
        
2.  **Create the Extracted Class**
    
    -   Move the **tightest cohesive cluster first**; give it a clear name and API.
        
3.  **Move Fields & Methods**
    
    -   Start with data + private methods that only touch that data.
        
    -   Replace original code with **delegation** calls.
        
4.  **Resolve Data Flow**
    
    -   Pass required state via constructor or intent methods (avoid wide setters).
        
    -   Consider **value objects** for grouped data (e.g., `PostalAddress`).
        
5.  **Run Tests After Each Move**
    
    -   Keep behavior constant; add missing unit tests if needed.
        
6.  **Tighten the Boundary**
    
    -   Remove dead code; minimize getters/setters that leak internals.
        
7.  **Repeat** for the next cluster (e.g., payment, printing).
    

---

## Sample Code (Java)

### Before — One class doing too much

```java
public class Order {
  private final List<OrderLine> lines = new ArrayList<>();
  private String street, city, postalCode, country;
  private boolean express;

  public void addLine(String sku, int qty, BigDecimal unitPrice) {
    lines.add(new OrderLine(sku, qty, unitPrice));
  }

  public BigDecimal total() {
    return lines.stream()
        .map(l -> l.unitPrice().multiply(BigDecimal.valueOf(l.qty())))
        .reduce(BigDecimal.ZERO, BigDecimal::add);
  }

  // address validation & normalization (unrelated to order math)
  public void setAddress(String street, String city, String postalCode, String country) {
    if (street == null || street.isBlank()) throw new IllegalArgumentException("street");
    if (postalCode == null || !postalCode.matches("\\w[\\w- ]+")) throw new IllegalArgumentException("postal");
    this.street = street.strip();
    this.city = city.strip();
    this.postalCode = postalCode.toUpperCase();
    this.country = country.toUpperCase();
  }

  // shipping rules (unrelated to order math)
  public BigDecimal shippingCost() {
    BigDecimal base = new BigDecimal("4.90");
    BigDecimal weightFee = BigDecimal.valueOf(lines.size()).multiply(new BigDecimal("0.50"));
    BigDecimal expressFee = express ? new BigDecimal("6.00") : BigDecimal.ZERO;
    if ("US".equals(country) && postalCode.startsWith("9")) {
      expressFee = expressFee.add(new BigDecimal("2.00")); // remote surcharge
    }
    return base.add(weightFee).add(expressFee);
  }

  public void setExpress(boolean express) { this.express = express; }

  // nested record for brevity
  private record OrderLine(String sku, int qty, BigDecimal unitPrice) {}
}
```

### After — Extract `PostalAddress` and `ShippingPolicy`

```java
// Value Object: PostalAddress (encapsulates validation/normalization)
public final class PostalAddress {
  private final String street, city, postalCode, country;

  public PostalAddress(String street, String city, String postalCode, String country) {
    if (street == null || street.isBlank()) throw new IllegalArgumentException("street");
    if (postalCode == null || !postalCode.matches("\\w[\\w- ]+")) throw new IllegalArgumentException("postal");
    this.street = street.strip();
    this.city = city.strip();
    this.postalCode = postalCode.toUpperCase();
    this.country = country.toUpperCase();
  }

  public String street() { return street; }
  public String city() { return city; }
  public String postalCode() { return postalCode; }
  public String country() { return country; }
}

// Policy: all shipping logic lives here
public class ShippingPolicy {
  private final boolean express;

  public ShippingPolicy(boolean express) { this.express = express; }

  public BigDecimal cost(PostalAddress address, int itemCount) {
    BigDecimal base = new BigDecimal("4.90");
    BigDecimal weightFee = BigDecimal.valueOf(itemCount).multiply(new BigDecimal("0.50"));
    BigDecimal expressFee = express ? new BigDecimal("6.00") : BigDecimal.ZERO;

    if ("US".equals(address.country()) && address.postalCode().startsWith("9")) {
      expressFee = expressFee.add(new BigDecimal("2.00")); // remote surcharge
    }
    return base.add(weightFee).add(expressFee);
  }
}

// Order now delegates; it’s smaller and cohesive
public class Order {
  private final List<OrderLine> lines = new ArrayList<>();
  private PostalAddress shippingAddress;
  private ShippingPolicy shipping; // injected or set by builder

  public Order withShippingPolicy(ShippingPolicy policy) {
    this.shipping = policy;
    return this;
  }

  public void setShippingAddress(PostalAddress address) { this.shippingAddress = address; }

  public void addLine(String sku, int qty, BigDecimal unitPrice) {
    lines.add(new OrderLine(sku, qty, unitPrice));
  }

  public BigDecimal total() {
    return lines.stream()
        .map(l -> l.unitPrice().multiply(BigDecimal.valueOf(l.qty())))
        .reduce(BigDecimal.ZERO, BigDecimal::add);
  }

  public BigDecimal shippingCost() {
    if (shipping == null || shippingAddress == null)
      throw new IllegalStateException("shipping policy/address not set");
    return shipping.cost(shippingAddress, lines.size());
  }

  private record OrderLine(String sku, int qty, BigDecimal unitPrice) {}
}
```

### Unit Test Sketch (guards behavior during extraction)

```java
class ShippingPolicyTest {

  @org.junit.jupiter.api.Test
  void usWestExpressSurchargeApplied() {
    var address = new PostalAddress("1 Main", "SF", "94107", "US");
    var policy  = new ShippingPolicy(true);

    var cost = policy.cost(address, 3);

    org.assertj.core.api.Assertions.assertThat(cost).isEqualByComparingTo("4.90"  // base
        .concat("+") // just a visual note; compute exact BigDecimal in real tests
    );
  }
}
```

> **Why this helps:**
> 
> -   `Order` now focuses on **order math and orchestration**.
>     
> -   `PostalAddress` owns **validation/normalization**.
>     
> -   `ShippingPolicy` holds **rules**; it’s reusable across contexts and easy to test in isolation.
>     

## Known Uses

-   Splitting **UI controllers** into controller + presenter/view model.
    
-   Extracting **pricing/discount** or **tax** policies from `Invoice/Order`.
    
-   Moving **persistence** concerns into repositories from domain objects.
    
-   Isolating **validation** into value objects (Email, Money, Address).
    
-   Decomposing **God services** into focused domain services.
    

## Related Patterns

-   **Extract Method / Move Method / Move Field:** Micro-steps often used during extraction.
    
-   **Extract Interface:** Publish a narrow contract for the new class.
    
-   **Introduce Parameter Object / Value Object:** Group related data passed across methods.
    
-   **Encapsulate Field / Encapsulate Collection:** Protect state on both sides of the split.
    
-   **Facade:** If clients need a single entry point while the internals are split.
    
-   **Strategy / Policy:** When extracted behavior varies by rules and should be swappable.

You: 

Fill out the following chapters for the Refactoring Pattern "Extract Interface": Pattern Name and Classification, Intent, Also Known As, Motivation (Forces), Applicability, Structure, Participants, Collaboration, Consequences, Implementation, Sample Code, Known Uses, Related Patterns In case code is useful provide a sample code in Java. Start with the pattern name and topic as title. Proceed with the chapters as listed. Do not provide any questions in the end.

ChatGPT: 

# Extract Interface — Refactoring Pattern

## Pattern Name and Classification

**Name:** Extract Interface  
**Classification:** Refactoring Pattern (Abstraction & Decoupling / Dependency Inversion)

## Intent

Introduce a **stable, minimal contract** that captures a client’s required behavior from an existing concrete class. Consumers then depend on the interface instead of the concrete type, enabling **substitution, testing with doubles, parallel implementations,** and safer evolution.

## Also Known As

-   Introduce Interface
    
-   Publish Contract
    
-   Dependency Inversion by Interface
    

## Motivation (Forces)

-   **Tight coupling:** Clients depend on a concrete class, making substitution and testing hard.
    
-   **Large surface area:** Consumers only need a subset of methods but are exposed to all of them.
    
-   **Parallel implementations:** Need to support multiple backends (e.g., in-memory, SQL, S3).
    
-   **Testability:** Mocking/stubbing is clumsy without a seam.
    
-   **Evolution:** Concrete class must change but you want to **stabilize a contract** for clients.
    

## Applicability

Apply when:

-   A class is used by many clients and you want to **freeze a minimal contract**.
    
-   You need alternate implementations (e.g., synchronous vs. async, local vs. remote).
    
-   You want to **mock** the dependency in unit tests without heavy frameworks.
    
-   Clients only use a **cohesive subset** of a class’s methods.
    

Avoid or defer when:

-   The class is internal, rarely reused, and unlikely to change.
    
-   You would create an interface with **a single method used once** (YAGNI).
    
-   Behavior is unstable and still being discovered—premature abstraction can ossify mistakes.
    

## Structure

```lua
Before:
+-------------------------+
| ConcreteService         |
| + save() + find() + ...|
+-----------▲-------------+
            |
         Clients (hard-coupled)

After:
+-------------------------+       +------------------------+
|       ServicePort       |<------|       Clients          |
|  (extracted interface)  |       +------------------------+
+-----------▲-------------+
            |
  +---------+---------+
  |                   |
+-----------+   +-------------+
| SqlService |   | InMemService|
+-----------+   +-------------+
```

## Participants

-   **Interface (Port):** The extracted, minimal contract used by clients.
    
-   **Concrete Implementation(s):** One or more classes implementing the interface.
    
-   **Clients:** Depend only on the interface; receive implementation via DI/factory.
    
-   **Composition Root:** Wires concrete implementations to interfaces (app startup, tests).
    

## Collaboration

-   Clients **program to the interface**, not the implementation.
    
-   Implementations can vary (e.g., different storage backends) without changing clients.
    
-   Tests provide **fakes/mocks** implementing the same interface.
    

## Consequences

**Benefits**

-   Reduced coupling; **substitutability** and parallel implementations.
    
-   **Improved testability** (lightweight stubs/mocks).
    
-   Supports clean architecture (ports & adapters), DIP, and SRP.
    
-   Enables incremental migration (keep old impl while introducing a new one).
    

**Liabilities / Trade-offs**

-   More types to maintain; risk of **anemic interfaces** if designed without care.
    
-   An interface that’s too broad becomes sticky and hard to evolve.
    
-   Binary compatibility concerns if you modify published interfaces (use versioning).
    

## Implementation

1.  **Identify the Client Usage Surface**
    
    -   Search references to the concrete class; record the methods actually used.
        
2.  **Define a Minimal Interface**
    
    -   Extract only the **cohesive** operations clients need (ISP). Name it by role, not technology (`CustomerRepository`, not `JdbcCustomerDao`).
        
3.  **Make the Concrete Class Implement It**
    
    -   Add `implements Interface` and ensure signatures match.
        
4.  **Replace Client Types**
    
    -   Change variables/params/fields from concrete type to the new interface.
        
5.  **Introduce Alternate Implementations** (optional)
    
    -   E.g., an in-memory or remote implementation for tests or new backends.
        
6.  **Wire via DI/Factories**
    
    -   Provide the concrete at composition root; avoid service locator antipatterns.
        
7.  **Harden with Tests & Contracts**
    
    -   Add **contract tests** shared by all implementations to guarantee behavioral parity.
        
8.  **Iterate**
    
    -   Split oversized interfaces (ISP), keep the contract stable, version if needed.
        

---

## Sample Code (Java)

### Before — Clients depend on a concrete repository

```java
public class SqlCustomerRepository { // concrete type leaks to clients
  private final DataSource ds;

  public SqlCustomerRepository(DataSource ds) { this.ds = ds; }

  public Optional<Customer> findById(String id) {
    // JDBC code...
    return Optional.empty();
  }

  public Customer save(Customer c) {
    // JDBC insert/update...
    return c;
  }

  public void delete(String id) {
    // JDBC delete...
  }
}

public class LoyaltyService {
  private final SqlCustomerRepository repo; // hard-coupled

  public LoyaltyService(SqlCustomerRepository repo) { this.repo = repo; }

  public int customerPoints(String id) {
    return repo.findById(id).map(Customer::points).orElse(0);
  }
}
```

### After — Extract an interface and program to it

```java
// 1) The extracted interface (minimal contract used by clients)
public interface CustomerRepository {
  Optional<Customer> findById(String id);
  Customer save(Customer c);
  void delete(String id);
}

// 2) Existing implementation now implements the interface
public class SqlCustomerRepository implements CustomerRepository {
  private final DataSource ds;
  public SqlCustomerRepository(DataSource ds) { this.ds = ds; }

  @Override
  public Optional<Customer> findById(String id) { /* JDBC */ return Optional.empty(); }

  @Override
  public Customer save(Customer c) { /* JDBC */ return c; }

  @Override
  public void delete(String id) { /* JDBC */ }
}

// 3) Client depends on interface, not concrete
public class LoyaltyService {
  private final CustomerRepository repo; // decoupled

  public LoyaltyService(CustomerRepository repo) { this.repo = repo; }

  public int customerPoints(String id) {
    return repo.findById(id).map(Customer::points).orElse(0);
  }
}

// 4) Alternate implementation for tests or another backend
public class InMemoryCustomerRepository implements CustomerRepository {
  private final Map<String, Customer> db = new java.util.concurrent.ConcurrentHashMap<>();

  @Override
  public Optional<Customer> findById(String id) { return Optional.ofNullable(db.get(id)); }

  @Override
  public Customer save(Customer c) { db.put(c.id(), c); return c; }

  @Override
  public void delete(String id) { db.remove(id); }
}

// 5) Composition root (example wiring)
public class App {
  public static void main(String[] args) {
    DataSource ds = /* ... */;
    CustomerRepository repo = new SqlCustomerRepository(ds);
    LoyaltyService service = new LoyaltyService(repo);
    // run app...
  }
}

// 6) Contract test to ensure all impls behave the same
abstract class CustomerRepositoryContractTest {

  protected abstract CustomerRepository repo();

  @org.junit.jupiter.api.Test
  void saveAndFindRoundTrip() {
    var input = new Customer("42", "Ada", 120);
    repo().save(input);
    var out = repo().findById("42");
    org.assertj.core.api.Assertions.assertThat(out).contains(input);
  }
}

class InMemoryCustomerRepositoryTest extends CustomerRepositoryContractTest {
  @Override protected CustomerRepository repo() { return new InMemoryCustomerRepository(); }
}

// simple value object for demo
public record Customer(String id, String name, int points) {}
```

**Notes:**

-   The **interface is minimal** and named by domain role (`CustomerRepository`).
    
-   Clients can now receive **Sql**, **InMemory**, or future **Remote** implementations without code changes.
    
-   The **contract test** prevents behavior drift between implementations.
    

## Known Uses

-   Hexagonal / Ports & Adapters: Define domain ports as interfaces; adapters implement them (DB, HTTP, MQ).
    
-   Swapping infrastructure providers (JDBC → JPA → HTTP service) while keeping domain intact.
    
-   Testing with **in-memory** or **fake** implementations to avoid heavy test fixtures.
    
-   Gradual strangler migration: Old and new adapters both implement the same interface during cutover.
    

## Related Patterns

-   **Dependency Inversion Principle (DIP):** Core rationale for extracting interfaces.
    
-   **Interface Segregation Principle (ISP):** Keep interfaces small and role-focused.
    
-   **Extract Class / Extract Module:** Often performed before or after to improve cohesion.
    
-   **Adapter / Bridge:** Provide alternate implementations behind a stable interface.
    
-   **Strategy:** When the interface represents swappable algorithms/policies.
    
-   **Facade:** Present a simplified interface on top of complex subsystems.

You: 

Fill out the following chapters for the Refactoring Pattern "Extract Method": Pattern Name and Classification, Intent, Also Known As, Motivation (Forces), Applicability, Structure, Participants, Collaboration, Consequences, Implementation, Sample Code, Known Uses, Related Patterns In case code is useful provide a sample code in Java. Start with the pattern name and topic as title. Proceed with the chapters as listed. Do not provide any questions in the end.

ChatGPT: 

# Extract Method — Refactoring Pattern

## Pattern Name and Classification

**Name:** Extract Method  
**Classification:** Refactoring Pattern (Control-Flow Simplification / Separation of Concerns)

## Intent

Improve readability, reuse, and testability by **moving a coherent fragment of code** (a block, loop, or conditional branch) into a **separately named method** with a clear purpose and parameters, replacing the original fragment with a call.

## Also Known As

-   Extract Function (general)
    
-   Introduce Subroutine
    
-   Decompose Method
    

## Motivation (Forces)

-   **Long methods hide intent:** Mixed calculations, validation, I/O, and branching blur the “story.”
    
-   **Change amplification:** Touching one concern risks breaking others co-located nearby.
    
-   **Duplicated fragments:** Similar code appears in multiple places.
    
-   **Poor testability:** Internal logic is hard to unit-test without heavy fixtures.
    
-   **Cognitive load:** Developers must track many local variables at once.
    

## Applicability

Apply when you see:

-   A method doing **more than one thing** (formatting + validation + persistence).
    
-   **Comment-labeled sections**—comments often hint at extractable intent.
    
-   **Deep nesting**, long loops, or complex predicates that would benefit from names.
    
-   **Repeated code** across methods or classes.
    

Avoid or postpone when:

-   The fragment is **truly trivial** and extraction would hurt clarity.
    
-   Extraction would create **leaky abstractions** (excessive parameters, awkward state coupling).
    
-   You are in a **hot path** where call overhead is measurable (rare; inline later if needed).
    

## Structure

```javascript
Before:
caller() {
  // [A] setup
  // [B] complex block worth naming
  // [C] wrap-up
}

After:
caller() {
  // [A] setup
  doComplexThing(args);       // named intention
  // [C] wrap-up
}

doComplexThing(params) { ... }   // extracted method
```

## Participants

-   **Original Method (Caller):** Orchestrates the high-level flow.
    
-   **Extracted Method(s):** Own one concern with a clear name and parameters.
    
-   **Collaborators:** Objects whose state/behavior the new method may use via parameters or fields.
    
-   **Tests:** Verify behavior before/after; new unit tests target the extracted method.
    

## Collaboration

-   The caller **delegates** to extracted methods by passing only the data they need (minimize coupling).
    
-   Extracted methods can become **reusable utilities** or move to more appropriate classes later (follow-up refactorings: *Move Method*, *Extract Class*).
    

## Consequences

**Benefits**

-   Methods read like **narratives** (“what” over “how”).
    
-   Enables reuse, isolated testing, and further refactorings.
    
-   Reduces duplication and local variable sprawl.
    

**Liabilities / Trade-offs**

-   Too many tiny methods can fragment the flow.
    
-   Poorly chosen boundaries lead to **chatty** parameter lists.
    
-   If extraction crosses wrong ownership, can **increase coupling**.
    

## Implementation

1.  **Identify a Cohesive Fragment**
    
    -   Look for code that reads like a single intention; keep side effects together.
        
2.  **Analyze Variables**
    
    -   Determine **inputs** (read-only), **modified values** (outputs), and **locals** you can recompute.
        
3.  **Create the Method**
    
    -   Name it by intention (`calculateTax`, `renderSummary`, `validateOrder`).
        
    -   Pass only necessary data; return a value if needed.
        
4.  **Replace the Original Code with a Call**
    
    -   Compile and run tests.
        
5.  **Adjust Visibility and Placement**
    
    -   Keep private initially; later consider moving to a better home (class/module).
        
6.  **Iterate**
    
    -   Repeat to flatten nesting (introduce **guard clauses**), and cluster extracted methods for later *Extract Class*.
        

---

## Sample Code (Java)

### 1) Before → After (basic extraction and naming)

**Before**

```java
public class InvoiceService {

  public String renderInvoice(Invoice invoice) {
    StringBuilder sb = new StringBuilder();

    // header
    sb.append("INVOICE ").append(invoice.id()).append("\n");
    sb.append("Customer: ").append(invoice.customerName()).append("\n");

    // lines + totals (complex, mixed concerns)
    BigDecimal total = BigDecimal.ZERO;
    for (LineItem li : invoice.items()) {
      BigDecimal lineTotal = li.unitPrice().multiply(BigDecimal.valueOf(li.quantity()));
      sb.append(li.sku()).append(" x").append(li.quantity())
        .append(" = ").append(lineTotal).append("\n");
      total = total.add(lineTotal);
    }
    BigDecimal tax = total.multiply(new BigDecimal("0.20"));
    BigDecimal grand = total.add(tax);

    // footer
    sb.append("Subtotal: ").append(total).append("\n");
    sb.append("Tax(20%): ").append(tax).append("\n");
    sb.append("Total: ").append(grand).append("\n");

    return sb.toString();
  }
}
```

**After**

```java
public class InvoiceService {

  public String renderInvoice(Invoice invoice) {
    StringBuilder sb = new StringBuilder();
    appendHeader(sb, invoice);
    BigDecimal subtotal = appendLinesAndComputeSubtotal(sb, invoice);
    appendTotals(sb, subtotal);
    return sb.toString();
  }

  private void appendHeader(StringBuilder sb, Invoice invoice) {
    sb.append("INVOICE ").append(invoice.id()).append("\n");
    sb.append("Customer: ").append(invoice.customerName()).append("\n");
  }

  private BigDecimal appendLinesAndComputeSubtotal(StringBuilder sb, Invoice invoice) {
    BigDecimal total = BigDecimal.ZERO;
    for (LineItem li : invoice.items()) {
      BigDecimal lineTotal = li.unitPrice().multiply(BigDecimal.valueOf(li.quantity()));
      sb.append(li.sku()).append(" x").append(li.quantity())
        .append(" = ").append(lineTotal).append("\n");
      total = total.add(lineTotal);
    }
    return total;
  }

  private void appendTotals(StringBuilder sb, BigDecimal subtotal) {
    BigDecimal tax = subtotal.multiply(new BigDecimal("0.20"));
    BigDecimal grand = subtotal.add(tax);
    sb.append("Subtotal: ").append(subtotal).append("\n");
    sb.append("Tax(20%): ").append(tax).append("\n");
    sb.append("Total: ").append(grand).append("\n");
  }
}
```

### 2) Deeper extraction with guard clauses and pure predicates

```java
public class BookingService {

  public Reservation book(BookingRequest req, Clock clock) {
    requireNonNull(req);
    if (isBlackout(req.date(), clock)) {
      throw new IllegalStateException("Blackout date");
    }
    if (!hasCapacity(req.roomType(), req.date())) {
      return Reservation.rejected("No capacity");
    }
    Money price = priceFor(req);
    return confirm(req, price);
  }

  // --- extracted pure predicates
  private boolean isBlackout(LocalDate date, Clock clock) {
    LocalDate today = LocalDate.now(clock);
    return date.isBefore(today) || isHoliday(date);
  }

  private boolean hasCapacity(RoomType type, LocalDate date) {
    // query cache or DB...
    return true;
  }

  // --- extracted actions
  private Money priceFor(BookingRequest req) {
    Money base = tariff(req.roomType(), req.date());
    return applyDiscounts(base, req.customerId());
  }

  private Reservation confirm(BookingRequest req, Money price) {
    // persist and emit event...
    return Reservation.confirmed(req.id(), price);
  }
}
```

### 3) Extract Method as a stepping stone to Extract Class

```java
public class ReportGenerator {

  public byte[] generateMonthlyReport(YearMonth ym) {
    List<Record> data = fetchData(ym);
    List<Record> cleaned = clean(data);
    String csv = toCsv(cleaned);     // extracted method
    return compress(csv);            // extracted method
  }

  // later these can move to a new CsvReport class
  private String toCsv(List<Record> rows) { /* ... */ return ""; }
  private byte[] compress(String payload) { /* ... */ return new byte[0]; }
}
```

### 4) Handling local variables (inputs/outputs) cleanly

```java
// Fragment computes a derived value used later: return it instead of mutating outer locals.
private BigDecimal computeGrandTotal(List<LineItem> items) {
  BigDecimal subtotal = items.stream()
      .map(li -> li.unitPrice().multiply(BigDecimal.valueOf(li.quantity())))
      .reduce(BigDecimal.ZERO, BigDecimal::add);
  BigDecimal tax = subtotal.multiply(new BigDecimal("0.20"));
  return subtotal.add(tax);
}
```

---

## Known Uses

-   Breaking down legacy “god methods” in controllers/services into **validation**, **calculation**, **persistence**, and **rendering** methods.
    
-   Extracting **predicate methods** (e.g., `isVipCustomer`, `isPeakTime`) for reuse across services.
    
-   Creating **self-documenting orchestration** in pipelines: `load()`, `transform()`, `save()`.
    
-   First step before **Extract Class**, **Extract Interface**, or moving logic into **policies/strategies**.
    

## Related Patterns

-   **Extract Class / Move Method:** Natural follow-ups when extracted groups form cohesive responsibilities.
    
-   **Introduce Parameter Object / Value Object:** Reduce long parameter lists after extraction.
    
-   **Decompose Conditional / Replace Conditional with Polymorphism:** Once branches are isolated, elevate to strategies.
    
-   **Consolidate Duplicate Code:** Replace repeated fragments with the extracted method.
    
-   **Guard Clauses:** Use early returns to flatten the caller after extraction.

You: 

Fill out the following chapters for the Refactoring Pattern "Inline Method": Pattern Name and Classification, Intent, Also Known As, Motivation (Forces), Applicability, Structure, Participants, Collaboration, Consequences, Implementation, Sample Code, Known Uses, Related Patterns In case code is useful provide a sample code in Java. Start with the pattern name and topic as title. Proceed with the chapters as listed. Do not provide any questions in the end.

ChatGPT: 

Nachgedacht für 6s

# Inline Method — Refactoring Pattern

## Pattern Name and Classification

**Name:** Inline Method  
**Classification:** Refactoring Pattern (Simplification / Remove Needless Indirection)

## Intent

Remove unnecessary abstraction by **replacing a method call with the method’s body**, simplifying control flow when the method **doesn’t add meaningful intent, abstraction, or reuse**.

## Also Known As

-   Inline Function / Inline Routine
    
-   Collapse Indirection
    
-   Undo Extract Method (when over-extracted)
    

## Motivation (Forces)

-   **Over-abstraction:** A tiny method just delegates without adding a domain name, validation, or reuse.
    
-   **Indirection tax:** Reading code requires extra jumps; stack traces and debugging are noisier.
    
-   **Performance hot paths:** Virtual dispatch or call overhead on extremely hot micro-paths (rare, but possible).
    
-   **Refactoring churn:** After earlier refactorings (Extract Method/Class), some helpers become trivial.
    

## Applicability

Apply when:

-   A method **only forwards** to another method or returns a simple expression.
    
-   The method **no longer reveals intent** better than the inlined code.
    
-   The method is **used in one/few places** and carries no API commitment.
    
-   Inlining **reduces cognitive load** (fewer hops to understand logic).
    

Avoid when:

-   The method **expresses intention** better than raw code (good name hides incidental complexity).
    
-   The method has **cross-cutting concerns** (validation, logging, caching, invariants).
    
-   It’s part of a **public API** where stability or polymorphism matters.
    
-   Tests rely on its **seam** (e.g., spy/mock points); consider keeping it or replacing with a different seam.
    

## Structure

```javascript
Before:
caller() {
  result = helper(x, y);      // tiny wrapper adds no value
}

helper(a, b) { return a + b; }

After:
caller() {
  result = x + y;              // direct logic; fewer hops
}
```

## Participants

-   **Caller:** Site(s) invoking the trivial method.
    
-   **Inlined Method:** Target method whose body will replace the call site.
    
-   **Collaborators:** Any dependencies referenced inside the method body.
    

## Collaboration

-   The **caller** absorbs the method’s logic, possibly introducing local variables for clarity.
    
-   If the inlined method called **another** method, consider inlining that as well (collapse delegation chain) or stop if intent would degrade.
    

## Consequences

**Benefits**

-   Simpler call graphs and **more readable** local logic.
    
-   Fewer files/methods to navigate; clearer stack traces.
    
-   Removes accidental abstraction and unlocks further refactorings (e.g., Decompose Conditional directly in the caller).
    

**Liabilities / Trade-offs**

-   **Duplication risk** if the method had multiple call sites—inline everywhere or keep a single source of truth.
    
-   May reduce **test seams**; tests might need to shift to higher-level behavior.
    
-   If overused, can **bloat** callers and hurt readability.
    

## Implementation

1.  **Preconditions & Safety**
    
    -   Ensure method is **simple**, has no significant side effects beyond what the caller already expects, and is not part of a **stable public API** (or version it).
        
    -   Run tests to capture current behavior.
        
2.  **Replace Calls with Body**
    
    -   For each call site, paste the body, **rename locals** to avoid clashes, and substitute parameters with arguments.
        
3.  **Handle Returns & Control Flow**
    
    -   If the method returns a value, assign directly or integrate expression.
        
    -   For void methods, inline statements preserving order and exceptions.
        
4.  **Remove the Original Method**
    
    -   Once all usages are replaced, delete the method.
        
    -   If some usages remain and you want one source, **stop**—don’t partially inline.
        
5.  **Clean Up**
    
    -   Simplify expressions, **introduce local variables** where naming helps.
        
    -   Re-run tests and static analysis.
        
6.  **Follow-ups**
    
    -   With indirection gone, consider **Extract Method** for genuinely cohesive substeps or **Decompose Conditional** on the now-local logic.
        

---

## Sample Code (Java)

### 1) Trivial Wrapper (best candidate)

**Before**

```java
public class PriceService {

  public BigDecimal totalWithVat(BigDecimal net) {
    return addVat(net); // needless hop
  }

  private BigDecimal addVat(BigDecimal net) {
    return net.multiply(new BigDecimal("1.20")).setScale(2, RoundingMode.HALF_EVEN);
  }
}
```

**After**

```java
public class PriceService {

  public BigDecimal totalWithVat(BigDecimal net) {
    return net.multiply(new BigDecimal("1.20")).setScale(2, RoundingMode.HALF_EVEN);
  }
  // addVat removed
}
```

### 2) Collapse Delegation Chain

**Before**

```java
class CustomerService {
  public boolean isVip(Customer c) { return hasVipStatus(c); }
  private boolean hasVipStatus(Customer c) { return "VIP".equalsIgnoreCase(c.tier()); }
}
```

**After**

```java
class CustomerService {
  public boolean isVip(Customer c) { return "VIP".equalsIgnoreCase(c.tier()); }
}
```

### 3) Hot Path Micro-Optimization (only if measured)

**Before**

```java
final class Vector2 {
  private final float x, y;
  public float dot(Vector2 other) { return dot(this.x, this.y, other.x, other.y); }
  private static float dot(float ax, float ay, float bx, float by) { return ax * bx + ay * by; }
}
```

**After**

```java
final class Vector2 {
  private final float x, y;
  public float dot(Vector2 other) { return this.x * other.x + this.y * other.y; }
}
```

*Note:* Only justify this when profiling shows call overhead matters.

### 4) Inline to Enable Further Refactoring

**Before**

```java
class DiscountService {
  public BigDecimal apply(Customer c, BigDecimal total) {
    return discounted(total, c.tier());
  }
  private BigDecimal discounted(BigDecimal amount, String tier) {
    return switch (tier) {
      case "GOLD" -> amount.multiply(new BigDecimal("0.85"));
      case "SILVER" -> amount.multiply(new BigDecimal("0.90"));
      default -> amount;
    };
  }
}
```

**After (then Decompose Conditional possible)**

```java
class DiscountService {
  public BigDecimal apply(Customer c, BigDecimal total) {
    return switch (c.tier()) {
      case "GOLD" -> total.multiply(new BigDecimal("0.85"));
      case "SILVER" -> total.multiply(new BigDecimal("0.90"));
      default -> total;
    };
  }
}
```

### 5) Guard Against Lost Invariants (don’t inline this)

**Before**

```java
class Account {
  private BigDecimal balance = BigDecimal.ZERO;
  public void deposit(BigDecimal amt) { applyDeposit(amt); }
  private void applyDeposit(BigDecimal amt) {
    if (amt == null || amt.signum() <= 0) throw new IllegalArgumentException();
    balance = balance.add(amt);
    audit("deposit", amt); // cross-cutting concern
  }
}
```

*This method carries validation + auditing; **do not** inline unless you keep those invariants at every call site or move them elsewhere first.*

---

## Known Uses

-   Cleaning up **over-extracted helpers** created during earlier refactorings.
    
-   Simplifying code in **builders**/**fluent APIs** where pass-through methods accumulated.
    
-   Reducing indirection in **delegation-heavy layers** after adopting a clearer architecture.
    
-   Tightening **private APIs** before publishing modules.
    

## Related Patterns

-   **Extract Method:** The inverse; use Inline when extraction no longer pays for itself.
    
-   **Inline Temp / Inline Variable:** Similar simplification for variables.
    
-   **Replace Temp with Query:** Sometimes inlining reveals an expression that should become a query.
    
-   **Inline Class / Collapse Hierarchy:** Higher-level analogs when entire types are redundant.
    
-   **Decompose Conditional:** Often becomes easier once logic is local.
    
-   **Encapsulate Field / Extract Class:** Keep invariants centralized before inlining methods that enforce them.

You: 

Fill out the following chapters for the Refactoring Pattern "Introduce Parameter Object": Pattern Name and Classification, Intent, Also Known As, Motivation (Forces), Applicability, Structure, Participants, Collaboration, Consequences, Implementation, Sample Code, Known Uses, Related Patterns In case code is useful provide a sample code in Java. Start with the pattern name and topic as title. Proceed with the chapters as listed. Do not provide any questions in the end.

ChatGPT: 

Nachgedacht für ein paar Sekunden

# Introduce Parameter Object — Refactoring Pattern

## Pattern Name and Classification

**Name:** Introduce Parameter Object  
**Classification:** Refactoring Pattern (API Simplification / Cohesion & Encapsulation)

## Intent

Replace **long or repetitive parameter lists** with a **single object** that groups related values (context), improving readability, cohesion, validation, and evolution of method signatures.

## Also Known As

-   Introduce *Context* Object
    
-   Group Parameters
    
-   Aggregate Parameters
    
-   Request Object / Command Object (when carrying intent)
    

## Motivation (Forces)

-   **Long parameter lists** are hard to read and call correctly; call sites become noisy.
    
-   **Duplication:** The same parameter clusters recur across multiple methods.
    
-   **Validation scattering:** Constraints get rechecked at each call site or method.
    
-   **Evolution pain:** Adding/removing parameters breaks many callers.
    
-   **Semantic grouping:** Certain values belong together temporally or domain-wise (e.g., date range, pagination, payment details).
    

## Applicability

Apply when:

-   A method accepts **3+ parameters**, often passed together elsewhere.
    
-   The same **tuple** shows up across many methods or classes.
    
-   There are **invariants across parameters** (e.g., `start <= end`, currency alignment).
    
-   You anticipate **API evolution** (adding options/flags) and want to avoid signature churn.
    

Avoid or defer when:

-   The parameters are **truly independent** and used only once.
    
-   You would create a **weak “bag-of-data”** with no meaningful invariants or behavior.
    
-   You are on a hot path and object allocation overhead is proven significant (rare in typical business systems).
    

## Structure

```css
Before:
report(fromDate, toDate, timezone, locale, currency, includeTax)

After:
report(ReportRequest request)

ReportRequest {
  DateRange range;
  Locale locale;
  ZoneId timezone;
  Currency currency;
  boolean includeTax;
}
```

## Participants

-   **Parameter Object (Context/Request):** Aggregates related values and invariants.
    
-   **Caller:** Builds the parameter object (builder/factory) and passes it.
    
-   **Callee:** Consumes the object, often delegating validation to it.
    
-   **Value Objects inside:** E.g., `DateRange`, `Money`, `PageRequest`.
    

## Collaboration

-   The **caller** constructs a valid parameter object (possibly via builder).
    
-   The **callee** receives a single argument, accesses strongly typed fields/methods, and can rely on **centralized validation**.
    
-   Parameter objects may carry **behavior** (e.g., `range.overlaps(other)`), not just data.
    

## Consequences

**Benefits**

-   **Readable signatures** and clearer intent at call sites.
    
-   **Centralized validation** and invariants; less duplication.
    
-   **Easier evolution** (add a field without changing method signatures).
    
-   Encourages **domain modeling** (value objects like `DateRange`, `Money`).
    
-   Better **testability**: create one object once and reuse across tests.
    

**Liabilities / Trade-offs**

-   Risk of **anemic “bags”** if no invariants/behavior are modeled.
    
-   Might **hide unnecessary parameters**—keep the object cohesive.
    
-   Additional type + construction code (mitigate with records/builders).
    

## Implementation

1.  **Spot Parameter Clusters**
    
    -   Search for repeated groups and long signatures.
        
2.  **Create a Parameter Object**
    
    -   Start with fields; encode **invariants in constructor** (or builder `.build()`). Prefer **immutable** objects.
        
3.  **Migrate the Callee**
    
    -   Replace the old parameter list with the new object; update internal usage.
        
4.  **Update Call Sites**
    
    -   Construct the object where values originate; remove duplicate validations.
        
5.  **Enrich with Behavior**
    
    -   Move related logic into the parameter object (e.g., `range.duration()`).
        
6.  **Iterate & Split**
    
    -   If the object grows unrelated concerns, **split** into cohesive sub-objects (ISP at object level).
        
7.  **Deprecate Old API** (if public)
    
    -   Provide an adapter overload temporarily; remove later.
        

---

## Sample Code (Java)

### 1) Before → After (basic grouping)

**Before**

```java
public class ReportService {
  public Report generate(LocalDate from, LocalDate to,
                         ZoneId zone, Locale locale,
                         Currency currency, boolean includeTax) {
    if (from.isAfter(to)) throw new IllegalArgumentException("from > to");
    // ... compute using all parameters ...
    return new Report();
  }
}
```

**After (Introduce Parameter Object)**

```java
public class ReportService {
  public Report generate(ReportRequest req) {
    // invariants already checked inside ReportRequest
    // ... compute using req.range(), req.zone(), req.locale(), ...
    return new Report();
  }
}
```

```java
public final class ReportRequest {
  private final DateRange range;
  private final ZoneId zone;
  private final Locale locale;
  private final Currency currency;
  private final boolean includeTax;

  private ReportRequest(DateRange range, ZoneId zone, Locale locale, Currency currency, boolean includeTax) {
    this.range = Objects.requireNonNull(range);
    this.zone = Objects.requireNonNull(zone);
    this.locale = Objects.requireNonNull(locale);
    this.currency = Objects.requireNonNull(currency);
    this.includeTax = includeTax;
  }

  public static Builder builder() { return new Builder(); }

  public DateRange range() { return range; }
  public ZoneId zone() { return zone; }
  public Locale locale() { return locale; }
  public Currency currency() { return currency; }
  public boolean includeTax() { return includeTax; }

  public static final class Builder {
    private LocalDate from, to;
    private ZoneId zone = ZoneId.of("UTC");
    private Locale locale = Locale.US;
    private Currency currency = Currency.getInstance("USD");
    private boolean includeTax = true;

    public Builder from(LocalDate v){ this.from = v; return this; }
    public Builder to(LocalDate v){ this.to = v; return this; }
    public Builder zone(ZoneId v){ this.zone = v; return this; }
    public Builder locale(Locale v){ this.locale = v; return this; }
    public Builder currency(Currency v){ this.currency = v; return this; }
    public Builder includeTax(boolean v){ this.includeTax = v; return this; }

    public ReportRequest build() {
      var range = new DateRange(from, to); // validates order
      return new ReportRequest(range, zone, locale, currency, includeTax);
    }
  }
}
```

```java
/** Value object with invariant */
public record DateRange(LocalDate from, LocalDate to) {
  public DateRange {
    Objects.requireNonNull(from); Objects.requireNonNull(to);
    if (from.isAfter(to)) throw new IllegalArgumentException("from must be <= to");
  }
  public long days() { return java.time.temporal.ChronoUnit.DAYS.between(from, to) + 1; }
}
```

**Usage**

```java
ReportRequest req = ReportRequest.builder()
    .from(LocalDate.of(2025, 1, 1))
    .to(LocalDate.of(2025, 1, 31))
    .zone(ZoneId.of("Europe/Vienna"))
    .locale(Locale.GERMANY)
    .currency(Currency.getInstance("EUR"))
    .includeTax(true)
    .build();

Report report = new ReportService().generate(req);
```

### 2) Evolving APIs without signature churn

```java
// Later you add pagination and export format without changing ReportService signature
public enum ExportFormat { PDF, CSV, XLSX }

public final class ReportRequest {
  // ... previous fields ...
  private final Integer page;
  private final Integer pageSize;
  private final ExportFormat format;

  // extend builder with sensible defaults
  // existing call sites remain source-compatible
}
```

### 3) Behavior inside the parameter object (not a bag of data)

```java
public final class PaymentCommand {
  private final Money amount;
  private final String creditorIban;
  private final String remittanceInfo;

  public PaymentCommand(Money amount, String creditorIban, String remittanceInfo) {
    this.amount = Objects.requireNonNull(amount);
    this.creditorIban = validateIban(creditorIban);
    this.remittanceInfo = sanitize(remittanceInfo);
  }

  public boolean isHighValue() { return amount.isGreaterThan(new Money("10000.00", "EUR")); }
  public String maskedIban() { return "****" + creditorIban.substring(credItorIban.length() - 4); }

  private String validateIban(String iban) {
    // domain validation...
    return iban.replace(" ", "");
  }
}
```

### 4) Test Example

```java
class ReportRequestTest {
  @org.junit.jupiter.api.Test
  void rangeValidation() {
    var b = ReportRequest.builder().from(LocalDate.of(2025,2,1)).to(LocalDate.of(2025,1,1));
    org.junit.jupiter.api.Assertions.assertThrows(IllegalArgumentException.class, b::build);
  }
}
```

---

## Known Uses

-   **Pagination** objects: `PageRequest(page, size, sort)` across repositories/APIs.
    
-   **Date/time windows**: `DateRange`, `TimeWindow`, `Schedule` in reporting or billing.
    
-   **Search filters**: `SearchCriteria` (keywords, tags, facets) in services/controllers.
    
-   **Money & Currency** grouped into `Money` value object rather than primitive pairs.
    
-   **Configuration bundles**: `RetryPolicy`, `HttpClientOptions`, `ExecutionContext`.
    
-   **Command/Query DTOs** in CQRS and hexagonal architectures.
    

## Related Patterns

-   **Extract Method / Extract Class:** Often precede/follow this refactoring to clarify responsibilities.
    
-   **Replace Parameter with Method Call:** When a parameter can be derived from an object already available.
    
-   **Introduce Parameter Map** (temporary step): Replace many optional parameters with a map—usually superseded by a typed object.
    
-   **Value Object / Record:** Use immutable, behavior-rich objects for grouped data.
    
-   **Builder Pattern:** Construct complex parameter objects safely and fluently.
    
-   **Encapsulate Field / Encapsulate Collection:** Guard state within the parameter object itself.
    
-   **Method Object (Replace Method with Method Object):** For very long methods where locals become fields of a temporary object (a heavier variant).

You: 

Fill out the following chapters for the Refactoring Pattern "Move Field": Pattern Name and Classification, Intent, Also Known As, Motivation (Forces), Applicability, Structure, Participants, Collaboration, Consequences, Implementation, Sample Code, Known Uses, Related Patterns In case code is useful provide a sample code in Java. Start with the pattern name and topic as title. Proceed with the chapters as listed. Do not provide any questions in the end.

ChatGPT: 

Nachgedacht für 5s

# Move Field — Refactoring Pattern

## Pattern Name and Classification

**Name:** Move Field  
**Classification:** Refactoring Pattern (Data Localization / Encapsulation & Cohesion)

## Intent

Relocate a field to the class where it **logically belongs and is primarily used**, improving cohesion, making invariants enforceable, and reducing feature envy and scattered knowledge.

## Also Known As

-   Move Data
    
-   Move Attribute / Relocate Member
    
-   Normalize Ownership of State
    

## Motivation (Forces)

-   **Feature envy:** Methods in another class keep reading/writing a field that sits “far away.”
    
-   **Weak invariants:** Validation and rules for a field can’t be enforced where the field lives.
    
-   **Tangled responsibilities:** A class holds configuration/state for a concept it doesn’t own.
    
-   **Change amplification:** Every change requires touching multiple classes because the data is elsewhere.
    
-   **Discoverability:** Developers look for a concept in its natural home; scattered fields slow understanding.
    

## Applicability

Apply when:

-   Most references/logic for a field occur in **another class** (or value object) than where it is declared.
    
-   The field’s **invariants** are best expressed/validated by another type.
    
-   A **new abstraction** emerged (e.g., `Money`, `PostalAddress`, `RetryPolicy`) that should own the state.
    
-   You’re preparing for **Extract Class** or **Replace Data Value with Object** and need to consolidate ownership.
    

Avoid or postpone when:

-   The field truly belongs to the current aggregate root for **transactional consistency**.
    
-   Moving the field would create **cross-aggregate coupling** or break persistence boundaries without a plan.
    
-   The field is **public API/serialization contract** you cannot change yet (introduce adapters first).
    

## Structure

```sql
Before:
+------------------+                 +-----------------------+
| Order            |  uses heavily   | ShippingPolicy        |
| - express : bool |---------------> | cost(..., express)    |
+------------------+                 +-----------------------+

After (moved field):
+------------------+                 +-----------------------+
| Order            |                 | ShippingPolicy        |
|                  |                 | - express : bool      |
|                  |                 | cost(...)             |
+------------------+                 +-----------------------+
```

## Participants

-   **Source Class:** Currently declares the field but doesn’t truly own its behavior.
    
-   **Target Class:** The class that owns the rules/behavior for the field.
    
-   **Clients:** Callers that read/write the field through methods; they must be migrated.
    
-   **Transitional Delegates (optional):** Temporary getters/setters left on the source class to preserve API during migration.
    

## Collaboration

-   The **target class** takes responsibility for invariants, defaulting, and mutation.
    
-   The **source class** delegates (temporarily) to the target or exposes intent-revealing operations.
    
-   Clients gradually switch to the target’s API or to new intent methods on the source.
    

## Consequences

**Benefits**

-   Higher cohesion; rules live next to the data.
    
-   Stronger invariants and simpler validation.
    
-   Clearer ownership and easier reuse/testing of the owning class.
    
-   Often reduces parameter/argument lists (less data shuttling).
    

**Liabilities / Trade-offs**

-   Short-term churn: migrations, serialization schema changes, database migrations.
    
-   Risk of **chatty interactions** if boundaries are drawn poorly.
    
-   Requires careful handling of **backward compatibility** (public APIs, events, JSON).
    

## Implementation

1.  **Identify the True Owner**
    
    -   Measure references: which class’s methods read/write the field most?
        
    -   Map invariants and who enforces them today.
        
2.  **Create/Choose Target Class**
    
    -   If missing, introduce a value object or policy class that naturally owns the field.
        
3.  **Add the Field to Target with Invariants**
    
    -   Initialize with safe defaults; add validation and intent-revealing accessors.
        
4.  **Redirect Behavior**
    
    -   Move methods using the field to the target (or delegate from source to target).
        
5.  **Migrate Call Sites**
    
    -   Update clients to use the target’s API (or new intent methods on the source).
        
    -   Keep **temporary delegating accessors** on the source (deprecated) to avoid big-bang changes.
        
6.  **Remove the Original Field**
    
    -   After all call sites migrate, delete the field from the source class.
        
    -   Update persistence/serialization and database schema if needed.
        
7.  **Regression Tests**
    
    -   Add/adjust tests for invariants now enforced by the target; keep integration tests green.
        

---

## Sample Code (Java)

### Scenario

An `Order` held an `express` flag used almost exclusively by `ShippingPolicy`. We move the field into `ShippingPolicy`, strengthen invariants, and give `Order` an intention-revealing API.

#### Before

```java
public class Order {
  private final List<OrderLine> lines = new ArrayList<>();
  private PostalAddress address;
  private boolean express; // <-- lives here but logic is in ShippingPolicy

  public void setExpress(boolean express) { this.express = express; }
  public boolean isExpress() { return express; }

  public BigDecimal shippingCost(ShippingPolicy policy) {
    return policy.cost(address, lines.size(), express);
  }

  // ...
}

public class ShippingPolicy {
  public BigDecimal cost(PostalAddress address, int itemCount, boolean express) {
    BigDecimal base = new BigDecimal("4.90");
    BigDecimal weightFee = BigDecimal.valueOf(itemCount).multiply(new BigDecimal("0.50"));
    BigDecimal expressFee = express ? new BigDecimal("6.00") : BigDecimal.ZERO;

    if ("US".equals(address.country()) && address.postalCode().startsWith("9")) {
      expressFee = expressFee.add(new BigDecimal("2.00"));
    }
    return base.add(weightFee).add(expressFee);
  }
}
```

#### After — Field moved; `Order` delegates intention, not state

```java
public class ShippingPolicy {

  private boolean express; // <-- moved field now owned here

  public ShippingPolicy express(boolean value) {
    this.express = value;
    return this;
  }

  public boolean isExpress() { return express; }

  public BigDecimal cost(PostalAddress address, int itemCount) {
    BigDecimal base = new BigDecimal("4.90");
    BigDecimal weightFee = BigDecimal.valueOf(itemCount).multiply(new BigDecimal("0.50"));
    BigDecimal expressFee = express ? new BigDecimal("6.00") : BigDecimal.ZERO;

    if ("US".equals(address.country()) && address.postalCode().startsWith("9")) {
      expressFee = expressFee.add(new BigDecimal("2.00"));
    }
    return base.add(weightFee).add(expressFee);
  }
}

public class Order {
  private final List<OrderLine> lines = new ArrayList<>();
  private PostalAddress address;
  private ShippingPolicy shipping = new ShippingPolicy();

  /** Intention-revealing behavior; no 'express' field here anymore */
  public Order withExpressShipping() { this.shipping.express(true); return this; }
  public Order withStandardShipping() { this.shipping.express(false); return this; }

  public BigDecimal shippingCost() {
    if (address == null) throw new IllegalStateException("address required");
    return shipping.cost(address, lines.size());
  }

  // Transitional delegators (optional, deprecate/remove later)
  /** @deprecated moved to ShippingPolicy */
  @Deprecated public void setExpress(boolean express) { this.shipping.express(express); }
  /** @deprecated moved to ShippingPolicy */
  @Deprecated public boolean isExpress() { return this.shipping.isExpress(); }
}
```

#### Variant — Moving a field into a Value Object to enforce invariants

```java
// Before: scattered fields
public class Event {
  public LocalDate start;
  public LocalDate end;
  public boolean overlaps(Event other) {
    return !start.isAfter(other.end) && !end.isBefore(other.start);
  }
}

// After: move fields into a cohesive value object with invariant
public class Event {
  private DateRange range; // moved ownership
  public boolean overlaps(Event other) { return range.overlaps(other.range); }
}

public record DateRange(LocalDate start, LocalDate end) {
  public DateRange {
    if (start.isAfter(end)) throw new IllegalArgumentException("start <= end");
  }
  public boolean overlaps(DateRange other) {
    return !start.isAfter(other.end) && !end.isBefore(other.start);
  }
}
```

---

## Known Uses

-   Moving **money/currency** fields into a `Money` value object to centralize rounding and currency rules.
    
-   Moving **timezone/locale** fields into a `UserPreferences` or request `Context` object.
    
-   Moving **rate/threshold** fields from services into **policy objects** to enable A/B testing/configuration.
    
-   Moving **connection**/**retry** fields from various HTTP clients into a shared `HttpClientOptions`.
    

## Related Patterns

-   **Move Method / Move Function:** Often accompanies Move Field to keep behavior with data.
    
-   **Extract Class / Replace Data Value with Object:** Create a new home that owns the field and its rules.
    
-   **Encapsulate Field / Encapsulate Collection:** After moving, protect the field properly.
    
-   **Introduce Parameter Object:** If multiple fields belong together across calls, bundle them.
    
-   **Inline Class / Collapse Hierarchy:** The inverse when the current home adds no value.
    
-   **Change Bidirectional Association to Unidirectional:** Revisit associations after moving fields to reduce coupling.

You: 

Fill out the following chapters for the Refactoring Pattern "Move Method": Pattern Name and Classification, Intent, Also Known As, Motivation (Forces), Applicability, Structure, Participants, Collaboration, Consequences, Implementation, Sample Code, Known Uses, Related Patterns In case code is useful provide a sample code in Java. Start with the pattern name and topic as title. Proceed with the chapters as listed. Do not provide any questions in the end.

ChatGPT: 

Nachgedacht für einige wenige Sekunden

# Move Method — Refactoring Pattern

## Pattern Name and Classification

**Name:** Move Method  
**Classification:** Refactoring Pattern (Behavior Localization / Cohesion & Encapsulation)

## Intent

Relocate a method to the class or module where it **logically belongs and primarily uses data/behavior**, improving cohesion, reducing feature envy, and clarifying ownership and APIs.

## Also Known As

-   Relocate Method
    
-   Move Operation
    
-   Normalize Ownership of Behavior
    

## Motivation (Forces)

-   **Feature envy:** A method heavily uses fields of another class more than its own.
    
-   **Scattered rules:** Domain rules live far from the data they govern, weakening invariants.
    
-   **Change amplification:** Modifying a rule requires edits across multiple classes.
    
-   **Discoverability:** Developers expect to find behavior next to the data it acts upon.
    
-   **Encapsulation & reuse:** The natural owner can enforce validation and expose a tighter API.
    

## Applicability

Apply when:

-   A method reads/writes **more state of another class** than its own.
    
-   The method’s **responsibility aligns** with another type (policy, value object, aggregate).
    
-   You plan to **Extract Class** and clustering behavior in the new class is the next step.
    
-   A service method is anemic and should live with the **rich domain object**.
    

Avoid or postpone when:

-   Moving would break **transaction boundaries** or invariants (e.g., across aggregates) without a plan.
    
-   The method intentionally **coordinates multiple collaborators** (orchestration)—keep it as an application/service method.
    
-   The target class becomes **overloaded** or introduces tight cyclic dependencies.
    

## Structure

```lua
Before:
+------------------+          +----------------------+
| OrderService     |          | Money                |
| - calcTotal(o)   | ----->   | (fields, rules)      |
+------------------+          +----------------------+

After:
+------------------+          +----------------------+
| OrderService     |          | Money                |
| (delegates)      |          | + plus(...)          |
| calcTotal -> o.total()      |                      |
+------------------+          +----------------------+
```

## Participants

-   **Source Class:** Current home of the method (often orchestration or anemic class).
    
-   **Target Class:** Natural owner of data/rules referenced by the method.
    
-   **Clients:** Callers that must be redirected to the new location.
    
-   **Transitional Delegator (optional):** Temporary method kept on source to preserve API while callers migrate.
    

## Collaboration

-   The **target** class implements the moved method and enforces invariants.
    
-   The **source** optionally delegates to the new method during migration.
    
-   Clients progressively switch to calling the target directly or via **intent-revealing** methods on the source.
    

## Consequences

**Benefits**

-   Higher cohesion; rules live with the data they govern.
    
-   Stronger, centralized invariants and fewer leaks.
    
-   Clearer ownership and simpler APIs; improved reuse and testability.
    

**Liabilities / Trade-offs**

-   Short-term churn (call-site changes, imports, visibility adjustments).
    
-   Potential for **chatty interactions** if boundaries are chosen poorly.
    
-   Requires careful handling of **public APIs** and serialization/evolution concerns.
    

## Implementation

1.  **Identify True Ownership**
    
    -   Inspect field usage; if a method touches another class’s state predominantly, that class likely owns the behavior.
        
2.  **Create Method on Target**
    
    -   Move logic; adapt parameters to use target’s own fields where possible. Encode **invariants** here.
        
3.  **Preserve Behavior**
    
    -   Keep a delegating method on the source (temporarily). Add tests if missing.
        
4.  **Migrate Call Sites**
    
    -   Replace calls to the source with calls to the target or with an **intent method** on the source that forwards.
        
5.  **Remove Delegator**
    
    -   After all callers are migrated, delete the old method.
        
6.  **Tighten Boundaries**
    
    -   Reduce visibility and remove now-unused getters/setters. Consider **Move Field** or **Extract Class** follow-ups.
        
7.  **Retest & Review**
    
    -   Run unit and integration tests; watch for cycles and over-exposure.
        

---

## Sample Code (Java)

### 1) Move calculation from service to domain (classic feature envy)

**Before**

```java
public class InvoiceService {
  public BigDecimal computeTotal(Invoice inv) {
    BigDecimal subtotal = inv.getLines().stream()
        .map(li -> li.unitPrice().multiply(BigDecimal.valueOf(li.quantity())))
        .reduce(BigDecimal.ZERO, BigDecimal::add);

    BigDecimal tax = subtotal.multiply(inv.getTaxRate());
    return subtotal.add(tax).setScale(2, RoundingMode.HALF_EVEN);
  }
}

public class Invoice {
  private final List<LineItem> lines;
  private final BigDecimal taxRate;
  // getters...
}
```

**After**

```java
public class Invoice {
  private final List<LineItem> lines;
  private final BigDecimal taxRate;

  /** Behavior moved here; rules live with data */
  public BigDecimal total() {
    BigDecimal subtotal = lines.stream()
        .map(li -> li.unitPrice().multiply(BigDecimal.valueOf(li.quantity())))
        .reduce(BigDecimal.ZERO, BigDecimal::add);
    BigDecimal tax = subtotal.multiply(taxRate);
    return subtotal.add(tax).setScale(2, RoundingMode.HALF_EVEN);
  }
}

public class InvoiceService {
  /** Transitional delegator (can be removed once callers use inv.total()) */
  @Deprecated
  public BigDecimal computeTotal(Invoice inv) {
    return inv.total();
  }
}
```

### 2) Move method into Value Object to enforce invariants

**Before**

```java
public class PriceCalculator {
  public BigDecimal convert(BigDecimal amount, String from, String to, BigDecimal rate) {
    if (from.equals(to)) return amount;
    if (rate == null || rate.signum() <= 0) throw new IllegalArgumentException("rate");
    return amount.multiply(rate).setScale(2, RoundingMode.HALF_UP);
  }
}
```

**After**

```java
public record Money(BigDecimal amount, String currency) {
  public Money {
    Objects.requireNonNull(amount); Objects.requireNonNull(currency);
    if (amount.scale() > 2) amount = amount.setScale(2, RoundingMode.HALF_UP);
  }
  public Money convertTo(String targetCurrency, BigDecimal rate) {
    Objects.requireNonNull(targetCurrency); Objects.requireNonNull(rate);
    if (currency.equals(targetCurrency)) return this;
    if (rate.signum() <= 0) throw new IllegalArgumentException("rate");
    return new Money(amount.multiply(rate).setScale(2, RoundingMode.HALF_UP), targetCurrency);
  }
}
```

### 3) Move method from consumer to provider (reduce data shuttling)

**Before**

```java
public class CartService {
  public boolean qualifiesForFreeShipping(Cart cart, ShippingPolicy policy) {
    return cart.itemsTotal().compareTo(policy.getFreeShippingThreshold()) >= 0
        && !policy.isBlackoutZip(cart.shippingAddress().postalCode());
  }
}
```

**After**

```java
public class ShippingPolicy {
  private final BigDecimal freeShippingThreshold;
  private final Set<String> blackoutPrefixes;

  public boolean qualifies(Cart cart) {
    return cart.itemsTotal().compareTo(freeShippingThreshold) >= 0
        && !isBlackoutZip(cart.shippingAddress().postalCode());
  }

  boolean isBlackoutZip(String postal) {
    return blackoutPrefixes.stream().anyMatch(postal::startsWith);
  }
}

public class CartService {
  public boolean qualifiesForFreeShipping(Cart cart, ShippingPolicy policy) {
    return policy.qualifies(cart); // delegate to owner of rules
  }
}
```

### 4) Move method into Policy/Strategy to enable swappability

**Before**

```java
public class DiscountService {
  public BigDecimal apply(BigDecimal total, Customer c) {
    if (c.isVip()) return total.multiply(new BigDecimal("0.85"));
    if (c.isEmployee()) return total.multiply(new BigDecimal("0.70"));
    return total;
  }
}
```

**After**

```java
public interface DiscountPolicy {
  BigDecimal apply(BigDecimal total, Customer c);
}

public class VipDiscount implements DiscountPolicy {
  public BigDecimal apply(BigDecimal total, Customer c) {
    return c.isVip() ? total.multiply(new BigDecimal("0.85")) : total;
  }
}

public class EmployeeDiscount implements DiscountPolicy {
  public BigDecimal apply(BigDecimal total, Customer c) {
    return c.isEmployee() ? total.multiply(new BigDecimal("0.70")) : total;
  }
}

public class DiscountService {
  private final List<DiscountPolicy> policies;
  public DiscountService(List<DiscountPolicy> policies) { this.policies = policies; }

  public BigDecimal applyAll(BigDecimal total, Customer c) {
    BigDecimal result = total;
    for (DiscountPolicy p : policies) result = p.apply(result, c);
    return result;
  }
}
```

---

## Known Uses

-   Shifting **domain calculations** from services/controllers into aggregates or value objects.
    
-   Moving **validation/normalization** into the owning type (e.g., `Email`, `PostalAddress`, `Money`).
    
-   Extracting **pricing/tax/shipping rules** into policy classes for configurability.
    
-   Relocating **integration glue** into adapters to follow Ports & Adapters/Hexagonal architecture.
    
-   Consolidating **time/date** logic into dedicated types to avoid duplication.
    

## Related Patterns

-   **Move Field:** Often accompanies Move Method so data and behavior co-reside.
    
-   **Extract Class:** Create a new home (policy/value object) before moving multiple methods.
    
-   **Extract Interface:** After moving, publish a narrow contract for swappable implementations.
    
-   **Encapsulate Field / Encapsulate Collection:** Protect state in the target after migration.
    
-   **Inline Method:** If, after moving, an old delegator adds no value, inline/remove it.
    
-   **Strategy / Policy:** Target for methods that vary by rule and need runtime selection.
    
-   **Introduce Parameter Object:** If moved methods still pass long tuples, group them.

You: 

Fill out the following chapters for the Refactoring Pattern "Replace Conditional With Polymorphism": Pattern Name and Classification, Intent, Also Known As, Motivation (Forces), Applicability, Structure, Participants, Collaboration, Consequences, Implementation, Sample Code, Known Uses, Related Patterns In case code is useful provide a sample code in Java. Start with the pattern name and topic as title. Proceed with the chapters as listed. Do not provide any questions in the end.

ChatGPT: 

# Replace Conditional with Polymorphism — Refactoring Pattern

## Pattern Name and Classification

**Name:** Replace Conditional with Polymorphism  
**Classification:** Refactoring Pattern (Behavioral Decomposition / Strategy via Subtype Dispatch)

## Intent

Eliminate complex `if/else` or `switch` statements that select behavior by a **type code** (status, kind, role) by moving each branch into a **polymorphic implementation**. Call sites then invoke a single operation on an abstract type; the runtime subtype selects the correct behavior.

## Also Known As

-   Replace Type Code with Subclasses
    
-   Replace Conditional with Strategy
    
-   Polymorphic Dispatch / Dynamic Dispatch
    
-   Table-Driven Polymorphism (variant)
    

## Motivation (Forces)

-   **Brittle decision blobs:** Long conditionals grow as rules evolve; every change touches the same hotspot.
    
-   **Scattered knowledge:** Branch-specific data, validation, and computations are tangled.
    
-   **Closed for extension:** Adding a new variant means editing central switch statements (“open/closed” violation).
    
-   **Testing friction:** Each branch needs separate setup; unit tests can’t target behavior cleanly.
    
-   **Duplication:** The same switch appears in multiple places for the same axis of variation.
    

## Applicability

Apply when:

-   A **stable axis of variation** (e.g., `VehicleType`, `CustomerTier`, `DocumentState`) drives branching.
    
-   The same conditional appears in **multiple methods/places**.
    
-   Branches operate on **the same conceptual operation** but differ in details.
    
-   You want **extensibility** (add new variants without changing existing callers).
    

Avoid or postpone when:

-   Branches perform **completely unrelated tasks** (split first with *Extract Method* or *Extract Class*).
    
-   The axis of variation is **transient/experimental** and likely to collapse soon.
    
-   There are only **two trivial branches** and they won’t grow.
    

## Structure

```java
Before:
+------------------+
| PricingService   |
|  price(o) {      |
|    switch (o.tier) {  // GOLD/SILVER/STANDARD
|      case GOLD: ...   |
|      case SILVER: ... |
|      default: ...     |
|    }                  |
|  }                    |
+------------------+

After:
+--------------------+   +------------------+  +-------------------+
| interface Tier     |   | GoldTier         |  | SilverTier        |
|  BigDecimal price(...) | BigDecimal price |  | BigDecimal price  |
+---------▲----------+   +---------▲--------+  +---------▲---------+
          |                            (other variants)
          |
   +------┴-------+
   | StandardTier |
   +--------------+

Caller:
   BigDecimal p = order.tier().price(order);
```

## Participants

-   **Abstract Type / Interface:** Declares the operation formerly guarded by conditionals.
    
-   **Concrete Variants (Subclasses/Strategies):** Implement branch-specific logic and invariants.
    
-   **Context/Caller:** Holds or is associated with the variant and calls the abstract operation.
    
-   **Factory/Mapper:** Constructs the proper variant from a code or configuration (during migration).
    

## Collaboration

-   The **caller** delegates: `variant.behavior(args)`—no switches.
    
-   New variants plug in by **adding a class** and wiring it; existing code remains unchanged.
    
-   Shared behavior can live in an **abstract base** with template methods or default hooks.
    

## Consequences

**Benefits**

-   Removes repetitive switches and central hotspots; **open for extension**.
    
-   Localizes rules and **strengthens invariants** per variant.
    
-   Improves **testability** (test each subtype independently).
    
-   Encourages **cohesive models** (variant-specific data sits with behavior).
    

**Liabilities / Trade-offs**

-   **More classes**/types; can feel heavyweight for small systems.
    
-   If the axis of variation changes, you may need to revisit the hierarchy.
    
-   Risk of **over-engineering** if there are few stable variants.
    

## Implementation

1.  **Identify the Axis of Variation**
    
    -   Confirm the switch/if is selecting by “kind”: status/type/tier/role.
        
2.  **Define the Polymorphic Contract**
    
    -   Create an interface/abstract class with the operation(s) replacing the conditional.
        
3.  **Create Concrete Variants**
    
    -   Move each branch’s logic (and data/invariants) into its own implementation.
        
4.  **Construct or Map Variants**
    
    -   Introduce a factory/mapper converting the old code (enum/int) to the new type.
        
5.  **Redirect Callers**
    
    -   Replace conditional sites with `variant.operation(…)`. Remove duplicated switches elsewhere.
        
6.  **Consolidate Shared Code**
    
    -   Move common parts to the base class or helpers; keep differences overridden.
        
7.  **Test & Remove Legacy Paths**
    
    -   Add subtype-specific tests and contract tests; delete the original conditional.
        

---

## Sample Code (Java)

### Before — Pricing by tier with a `switch`

```java
public class PricingService {

  public BigDecimal priceFor(Order order) {
    BigDecimal total = order.items().stream()
        .map(li -> li.unitPrice().multiply(BigDecimal.valueOf(li.qty())))
        .reduce(BigDecimal.ZERO, BigDecimal::add);

    switch (order.tier()) {
      case GOLD:
        return total.multiply(new BigDecimal("0.85")).setScale(2, RoundingMode.HALF_EVEN);
      case SILVER:
        return total.multiply(new BigDecimal("0.90")).setScale(2, RoundingMode.HALF_EVEN);
      default:
        return total.setScale(2, RoundingMode.HALF_EVEN);
    }
  }
}

enum CustomerTier { GOLD, SILVER, STANDARD; }

record Order(List<LineItem> items, CustomerTier tier) {}
record LineItem(String sku, int qty, BigDecimal unitPrice) {}
```

### After — Polymorphism (subtypes/strategies)

```java
public interface TierPricing {
  BigDecimal priceFor(Order order);
}

public abstract class BaseTierPricing implements TierPricing {
  protected BigDecimal subtotal(Order order) {
    return order.items().stream()
        .map(li -> li.unitPrice().multiply(BigDecimal.valueOf(li.qty())))
        .reduce(BigDecimal.ZERO, BigDecimal::add);
  }
  protected BigDecimal scale(BigDecimal v) { return v.setScale(2, RoundingMode.HALF_EVEN); }
}

public final class GoldPricing extends BaseTierPricing {
  public BigDecimal priceFor(Order order) {
    return scale(subtotal(order).multiply(new BigDecimal("0.85")));
  }
}
public final class SilverPricing extends BaseTierPricing {
  public BigDecimal priceFor(Order order) {
    return scale(subtotal(order).multiply(new BigDecimal("0.90")));
  }
}
public final class StandardPricing extends BaseTierPricing {
  public BigDecimal priceFor(Order order) {
    return scale(subtotal(order));
  }
}

public class TierPricingFactory {
  public static TierPricing of(CustomerTier tier) {
    return switch (tier) {
      case GOLD -> new GoldPricing();
      case SILVER -> new SilverPricing();
      case STANDARD -> new StandardPricing();
    };
  }
}

public class PricingService {

  public BigDecimal priceFor(Order order) {
    TierPricing pricing = TierPricingFactory.of(order.tier());
    return pricing.priceFor(order); // no switch here
  }
}
```

### Variant — Strategy chosen once and cached (no factory at each call)

```java
public final class Customer {
  private final TierPricing pricing; // chosen at creation or login
  public Customer(TierPricing pricing) { this.pricing = pricing; }
  public BigDecimal price(Order order) { return pricing.priceFor(order); }
}
```

### Variant — Table-driven polymorphism without subclasses

```java
public final class MapPricing implements TierPricing {
  private final Function<BigDecimal, BigDecimal> rule;

  private MapPricing(Function<BigDecimal, BigDecimal> rule) { this.rule = rule; }

  public static Map<CustomerTier, TierPricing> rules() {
    return Map.of(
      CustomerTier.GOLD,    new MapPricing(s -> s.multiply(new BigDecimal("0.85"))),
      CustomerTier.SILVER,  new MapPricing(s -> s.multiply(new BigDecimal("0.90"))),
      CustomerTier.STANDARD,new MapPricing(s -> s)
    );
  }

  @Override public BigDecimal priceFor(Order order) {
    BigDecimal subtotal = order.items().stream()
        .map(li -> li.unitPrice().multiply(BigDecimal.valueOf(li.qty())))
        .reduce(BigDecimal.ZERO, BigDecimal::add);
    return subtotal.setScale(2, RoundingMode.HALF_EVEN)
                   .multiply(rule.apply(BigDecimal.ONE)) // apply factor
                   .setScale(2, RoundingMode.HALF_EVEN);
  }
}
```

---

## Known Uses

-   **State-dependent behavior:** Order/Document **state machines** where actions vary by state (`submit`, `cancel`, `approve`).
    
-   **Pricing/Discount engines:** Different discount rules by tier/segment/market.
    
-   **Tax/VAT rules by jurisdiction:** Each region encapsulates its calculation.
    
-   **Shipping rules by carrier:** Labeling, cost, and constraints per carrier strategy.
    
-   **Rendering/output formats:** PDF/CSV/JSON writers behind a `ReportRenderer` interface.
    
-   **Game development:** Entity behaviors per class (enemy AI strategies).
    

## Related Patterns

-   **Strategy:** The usual implementation vehicle; select algorithm at runtime.
    
-   **State:** When the variant is a **mutable lifecycle state** that transitions (the object holds a current state).
    
-   **Template Method:** Shared steps in base class with variant hooks.
    
-   **Factory / Abstract Factory:** To build the right variant from codes/config.
    
-   **Replace Type Code with Subclasses:** Close cousin when a field holds a type code.
    
-   **Decompose Conditional / Extract Method:** Often preparatory steps before introducing polymorphism.
    
-   **Introduce Parameter Object:** If branches pass the same long tuple, group it for cleaner variant APIs.

You: 

Fill out the following chapters for the Refactoring Pattern "Replace Delegation With Inheritance": Pattern Name and Classification, Intent, Also Known As, Motivation (Forces), Applicability, Structure, Participants, Collaboration, Consequences, Implementation, Sample Code, Known Uses, Related Patterns In case code is useful provide a sample code in Java. Start with the pattern name and topic as title. Proceed with the chapters as listed. Do not provide any questions in the end.

ChatGPT: 

# Replace Delegation with Inheritance — Refactoring Pattern

## Pattern Name and Classification

**Name:** Replace Delegation with Inheritance  
**Classification:** Refactoring Pattern (API Simplification / Remove Boilerplate)

## Intent

When a class delegates **most** of its behavior to a single field of another class (the *delegate*), replace that delegation with **subclassing the delegate’s type** so that forwarding methods disappear and the subclass can override or extend behavior directly.

## Also Known As

-   Collapse Wrapper to Subclass
    
-   Remove Forwarding Layer
    
-   Inherit Instead of Delegate (the inverse of “Replace Inheritance with Delegation”)
    

## Motivation (Forces)

-   **Delegation boilerplate:** The wrapper forwards dozens of methods to one object, adding maintenance cost and noise.
    
-   **Performance & clarity:** Layers of forwarding complicate stack traces and may add tiny overhead.
    
-   **Customization points:** You want to override a few operations while keeping all others as-is—subclassing offers protected hooks.
    
-   **Discoverability:** Consumers can use the subclass **as the base type**, avoiding wrapper-specific APIs.
    

Counter-forces:

-   **Fragile base class:** Inheritance tightly couples subclass to superclass internals.
    
-   **Binary compatibility & evolution:** Superclass changes can break subclasses.
    
-   **Encapsulation:** Delegation can enforce invariants or mediate access; inheritance bypasses that mediation.
    

## Applicability

Use when **all (or nearly all)** of these hold:

-   The class exists mainly to **wrap a single delegate** and forward most methods.
    
-   The delegate’s type is **meant to be extended** (non-final, protected hooks, documented extension points).
    
-   You need to **override/extend** a small subset of operations while keeping default behavior for the rest.
    
-   You can accept tighter coupling to the superclass and its evolution.
    

Avoid when:

-   The delegate type is **final** or not designed for inheritance (no hooks, unstable internals).
    
-   You need to **compose** multiple delegates (inheritance can’t model multiple sources).
    
-   The wrapper enforces **critical invariants**, security checks, or caching—inheritance could bypass them.
    
-   You’re crossing **module/service boundaries** where composition is safer (“prefer composition over inheritance”).
    

## Structure

```mathematica
Before (Delegation):
+-------------------+        delegates to        +-------------------+
| LoggingList<E>    |--------------------------->| ArrayList<E>      |
| - List<E> inner   |  add(), get(), size() ... |                   |
| + add(...) { inner.add(...) }                 |                   |
+-------------------+                            +-------------------+

After (Inheritance):
+---------------------------+
| LoggingArrayList<E>       |
| extends ArrayList<E>      |
| + add(...) { super.add... |
|   log(...) }              |
+---------------------------+
```

## Participants

-   **Subclass (New Class):** Replaces the wrapper; extends the former delegate’s type.
    
-   **Superclass (Former Delegate Type):** Provides default behavior and overridable hooks.
    
-   **Clients:** Now depend directly on the superclass type via polymorphism (the subclass *is-a* the superclass).
    

## Collaboration

-   Clients can pass the subclass anywhere the superclass is expected.
    
-   Overridden methods add behavior (logging, validation) and call `super` for the default.
    
-   Non-overridden behavior is inherited automatically—no forwarding needed.
    

## Consequences

**Benefits**

-   Eliminates forwarding **boilerplate**; smaller surface.
    
-   Natural **polymorphism**: subclass can be used wherever the base type is expected.
    
-   Simpler stack traces and potential micro-optimizations (no extra call layer).
    

**Liabilities / Trade-offs**

-   **Tight coupling** to superclass representation and lifecycle (fragile base class).
    
-   **Inheritance leaks**: public/protected members expose more than composition.
    
-   **Reduced flexibility**: only one inheritance line; hard to combine behaviors.
    
-   **LSP risks**: Overriding must preserve base class contracts.
    

## Implementation

1.  **Check Extensibility**
    
    -   Ensure the delegate’s class is not `final`, has a stable API, and is intended for extension.
        
2.  **Create Subclass**
    
    -   Make the new class extend the delegate’s type.
        
3.  **Move Enhancements**
    
    -   Copy the wrapper’s added logic into **overrides** (e.g., `add`, `remove`, `get`). Call `super` as appropriate.
        
4.  **Delete Forwarders**
    
    -   Remove delegation field and forwarding methods; rely on inherited behavior.
        
5.  **Migrate Clients**
    
    -   Replace wrapper type with the new subclass wherever constructed or referenced.
        
6.  **Re-test & Guard Contracts**
    
    -   Verify invariants and side-effects remain correct; write tests for overridden methods.
        
7.  **Document Constraints**
    
    -   Note any superclass expectations (thread-safety, mutation semantics).
        

---

## Sample Code (Java)

### Before — Delegation with boilerplate

```java
public class LoggingList<E> implements List<E> {

  private final List<E> inner;

  public LoggingList(List<E> inner) {
    this.inner = Objects.requireNonNull(inner);
  }

  @Override public boolean add(E e) {
    System.out.println("[add] " + e);
    return inner.add(e);
  }

  @Override public E get(int index) { return inner.get(index); }
  @Override public int size() { return inner.size(); }
  @Override public void clear() { inner.clear(); }
  @Override public boolean remove(Object o) { return inner.remove(o); }
  // ... dozens more forwarders ...
}
```

### After — Inheritance; override only what you customize

```java
public class LoggingArrayList<E> extends ArrayList<E> {

  public LoggingArrayList() { super(); }
  public LoggingArrayList(Collection<? extends E> c) { super(c); }
  public LoggingArrayList(int initialCapacity) { super(initialCapacity); }

  @Override
  public boolean add(E e) {
    System.out.println("[add] " + e);
    return super.add(e);
  }

  @Override
  public void add(int index, E element) {
    System.out.println("[add@" + index + "] " + element);
    super.add(index, element);
  }

  @Override
  public E remove(int index) {
    E removed = super.remove(index);
    System.out.println("[remove@" + index + "] " + removed);
    return removed;
  }
}
```

**Usage**

```java
List<String> names = new LoggingArrayList<>();
names.add("Ada");
names.add("Grace");
System.out.println(names.size()); // inherited, no forwarding layer
```

### Variant — Prefer extending an abstract base designed for inheritance

```java
public class LoggingList2<E> extends java.util.AbstractList<E> {
  private final List<E> inner = new ArrayList<>();

  @Override public E get(int index) { return inner.get(index); }
  @Override public int size() { return inner.size(); }

  @Override
  public boolean add(E e) {
    System.out.println("[add] " + e);
    return inner.add(e);
  }
}
```

*Why:* `AbstractList` exposes a **narrower** contract and fewer override points than `ArrayList`, reducing coupling.

---

## Known Uses

-   Custom collections that need small cross-cutting behavior (logging, metrics, access checks) without maintaining dozens of forwarders.
    
-   Framework extension points designed for inheritance (e.g., Spring’s `OncePerRequestFilter`, Servlet `HttpServlet`).
    
-   GUI toolkits (Swing/JavaFX) where components are commonly subclassed to tweak behavior.
    

## Related Patterns

-   **Replace Inheritance with Delegation:** The inverse; use when inheritance causes fragility or you need composition.
    
-   **Decorator:** If you want to stack behaviors at runtime, prefer composition over inheritance.
    
-   **Template Method:** Provide hooks in a base class to customize steps safely.
    
-   **Strategy:** Encapsulate the variable behavior instead of subclassing.
    
-   **Extract Superclass / Extract Interface:** If multiple classes share behavior, refactor toward shared abstractions first.
    

**Note:** Use this pattern **sparingly**. Favor **composition** by default; adopt inheritance only when the base class is explicitly designed to be extended and the benefits clearly outweigh the coupling.

You: 

Fill out the following chapters for the Refactoring Pattern "Replace Inheritance With Delegation": Pattern Name and Classification, Intent, Also Known As, Motivation (Forces), Applicability, Structure, Participants, Collaboration, Consequences, Implementation, Sample Code, Known Uses, Related Patterns In case code is useful provide a sample code in Java. Start with the pattern name and topic as title. Proceed with the chapters as listed. Do not provide any questions in the end.

ChatGPT: 

Nachgedacht für 6s

# Replace Inheritance with Delegation — Refactoring Pattern

## Pattern Name and Classification

**Name:** Replace Inheritance with Delegation  
**Classification:** Refactoring Pattern (Decoupling / Composition over Inheritance)

## Intent

Remove an inappropriate “is-a” relationship by **stopping subclassing** a framework/base class and instead **wrapping** it as an internal field. Forward only the operations you truly need and add behavior in the wrapper, reducing coupling to fragile superclasses and enabling safer evolution and composition.

## Also Known As

-   Prefer Composition over Inheritance
    
-   Replace Subclassing with Wrapper / Adapter
    
-   Deinherit / Decouple from Base Class
    

## Motivation (Forces)

-   **Fragile base class:** Superclass changes break subclasses; protected internals tempt tight coupling.
    
-   **Leaky inheritance:** Subclass inherits unwanted API surface and semantics (equals/hashCode, serialization, mutability).
    
-   **Multiple behaviors:** Need to combine concerns (logging + caching) — single inheritance can’t compose.
    
-   **Testability & substitutability:** You want to inject a different provider at runtime (e.g., `List` to `CopyOnWriteArrayList`).
    
-   **Security/invariants:** You must enforce pre/postconditions; inheritance can bypass the intended seams.
    

## Applicability

Apply when:

-   Your subclass **overrides few methods** and mostly reuses base behavior.
    
-   You need to **stack behaviors** (decorator-style) or swap the underlying implementation.
    
-   The superclass is **not designed for extension** (final methods, undocumented hooks).
    
-   Inheritance exposes **too much API** or violates domain rules (wrong equality, iteration order, lifecycle).
    

Avoid or defer when:

-   The superclass is **explicitly designed for inheritance** with stable hooks and you need most of its API.
    
-   Performance constraints make extra indirection unacceptable (rare; measure first).
    
-   You must be **recognized as the base type** for third-party APIs without adapter seams.
    

## Structure

```typescript
Before (Inheritance):
+--------------------------+
| NotifyingArrayList<E>    |  extends ArrayList<E>
|  + add(...) { ... }      |
|  + remove(...) { ... }   |
|  // inherits all API     |
+--------------------------+

After (Delegation / Wrapper):
+----------------------------+
| NotifyingList<E>           | implements List<E>
|  - List<E> inner           |  (Any List impl)
|  + add(...) { ...; inner } |
|  + remove(...) { ...; }    |
|  + of(…) factory           |
+----------------------------+
```

## Participants

-   **Wrapper / Delegate Owner:** New class that holds a reference to the real worker and exposes only the needed API.
    
-   **Delegate:** The composed object (e.g., `List<E>`, `HttpClient`) providing core functionality.
    
-   **Clients:** Use the wrapper’s narrower, intention-revealing API (optionally still the same interface).
    
-   **Optional Listeners/Policies:** Plug-in behaviors that the wrapper coordinates.
    

## Collaboration

-   Wrapper validates/augments calls, then **delegates** to the inner object.
    
-   The underlying implementation can be **swapped** (factories/DI) without touching clients.
    
-   Multiple wrappers can **compose** (metrics → caching → retry).
    

## Consequences

**Benefits**

-   **Reduced coupling** to framework internals; safer upgrades.
    
-   **Smaller surface area** (expose only what you need).
    
-   **Composable** behaviors (decorator chains).
    
-   Improved **testability** (inject fakes/mocks of the delegate).
    
-   Stronger **invariants** (central validation/logging/retry).
    

**Liabilities / Trade-offs**

-   A bit of **boilerplate** to forward methods (tools can generate).
    
-   Potential **indirection overhead** (usually negligible).
    
-   If you still need the full interface (e.g., `List`), you may end up forwarding many methods—prefer narrower ports when possible.
    

## Implementation

1.  **Identify the leakage:** List all places where inheritance forces you to inherit/override more than needed.
    
2.  **Create the Wrapper:** Add a field of the former superclass type (ideally an **interface** like `List`, `Map`, `HttpClient`).
    
3.  **Expose a Minimal API:** Implement exactly the methods clients need (or the same interface if required).
    
4.  **Forward Intentionally:** Delegate to the inner object; add validation, logging, retries, metrics as needed.
    
5.  **Construct via Factory/DI:** Provide constructors/factories to choose the inner implementation.
    
6.  **Migrate Call Sites:** Replace `new Subclass()` with wrapper factories; fix types if you narrowed the surface.
    
7.  **Remove Subclass:** Delete the old inheritance; re-run tests and contract tests.
    
8.  **Compose Further:** If more behaviors are needed, layer wrappers (decorators) or inject policies.
    

---

## Sample Code (Java)

### Before — Inheriting from a concrete collection

```java
// Inherits a huge API and is tightly coupled to ArrayList internals.
public class NotifyingArrayList<E> extends ArrayList<E> {

  private final Consumer<E> onAdd;

  public NotifyingArrayList(Consumer<E> onAdd) {
    this.onAdd = onAdd;
  }

  @Override
  public boolean add(E e) {
    boolean ok = super.add(e);
    if (ok) onAdd.accept(e);
    return ok;
  }

  @Override
  public void add(int index, E element) {
    super.add(index, element);
    onAdd.accept(element);
  }
  // inherits everything else whether we want it or not
}
```

### After — Delegate to any `List<E>` (composition)

```java
import java.util.*;
import java.util.function.Consumer;

public class NotifyingList<E> implements List<E> {

  private final List<E> inner;
  private final Consumer<E> onAdd;

  private NotifyingList(List<E> inner, Consumer<E> onAdd) {
    this.inner = Objects.requireNonNull(inner);
    this.onAdd = Objects.requireNonNull(onAdd);
  }

  /** Factory: choose underlying impl without changing clients */
  public static <E> NotifyingList<E> of(List<E> inner, Consumer<E> onAdd) {
    return new NotifyingList<>(inner, onAdd);
  }

  @Override
  public boolean add(E e) {
    boolean ok = inner.add(e);
    if (ok) onAdd.accept(e);
    return ok;
    // You could also forbid nulls or enforce domain invariants here.
  }

  @Override
  public void add(int index, E element) {
    inner.add(index, element);
    onAdd.accept(element);
  }

  @Override public E remove(int index) { return inner.remove(index); }
  @Override public boolean remove(Object o) { return inner.remove(o); }
  @Override public int size() { return inner.size(); }
  @Override public boolean isEmpty() { return inner.isEmpty(); }
  @Override public E get(int index) { return inner.get(index); }
  @Override public Iterator<E> iterator() { return inner.iterator(); }
  @Override public boolean contains(Object o) { return inner.contains(o); }
  @Override public Object[] toArray() { return inner.toArray(); }
  @Override public <T> T[] toArray(T[] a) { return inner.toArray(a); }
  @Override public boolean containsAll(Collection<?> c) { return inner.containsAll(c); }
  @Override public boolean addAll(Collection<? extends E> c) {
    boolean changed = false;
    for (E e : c) changed |= add(e); // ensures notifications per element
    return changed;
  }
  @Override public boolean addAll(int index, Collection<? extends E> c) {
    int i = index; boolean changed = false;
    for (E e : c) { add(i++, e); changed = true; }
    return changed;
  }
  @Override public void clear() { inner.clear(); }
  @Override public E set(int index, E element) { return inner.set(index, element); }
  @Override public int indexOf(Object o) { return inner.indexOf(o); }
  @Override public int lastIndexOf(Object o) { return inner.lastIndexOf(o); }
  @Override public ListIterator<E> listIterator() { return inner.listIterator(); }
  @Override public ListIterator<E> listIterator(int index) { return inner.listIterator(index); }
  @Override public List<E> subList(int fromIndex, int toIndex) { return inner.subList(fromIndex, toIndex); }
  @Override public boolean retainAll(Collection<?> c) { return inner.retainAll(c); }
  @Override public boolean removeAll(Collection<?> c) { return inner.removeAll(c); }
  @Override public boolean addAll(int index, Collection<? extends E> c, boolean dummy) { return addAll(index, c); } // optional

  // equals/hashCode/toString can delegate intentionally:
  @Override public String toString() { return "Notifying" + inner.toString(); }
}
```

**Usage**

```java
List<String> base = new ArrayList<>();
NotifyingList<String> names = NotifyingList.of(base, s -> System.out.println("Added: " + s));
names.add("Ada");
names.add("Grace");
// Can swap base to LinkedList, CopyOnWriteArrayList, etc., without changing clients.
```

### Variant — Narrow the surface (preferred)

Instead of implementing `List<E>` (which forces many forwarders), publish a **smaller port** that fits your domain.

```java
public interface AppendOnlyLog<E> {
  void append(E e);
  int size();
  Iterable<E> readAll();
}

public final class NotifyingLog<E> implements AppendOnlyLog<E> {
  private final List<E> inner;
  private final Consumer<E> onAppend;

  public NotifyingLog(List<E> inner, Consumer<E> onAppend) {
    this.inner = inner; this.onAppend = onAppend;
  }

  @Override public void append(E e) { inner.add(e); onAppend.accept(e); }
  @Override public int size() { return inner.size(); }
  @Override public Iterable<E> readAll() { return Collections.unmodifiableList(inner); }
}
```

*This avoids forwarding the entire `List` API and models the domain explicitly.*

---

## Known Uses

-   Replacing `extends Thread` with a class that **delegates to** a `Runnable` and is scheduled by an `ExecutorService`.
    
-   Wrapping HTTP clients (e.g., `HttpClient`) to add **retries, tracing, metrics**, without inheriting internal behavior.
    
-   Using **decorators** for caching/logging/authorization around repositories or services (Hexagonal Architecture).
    
-   GUI frameworks: wrap widgets instead of subclassing fragile concrete components.
    

## Related Patterns

-   **Replace Delegation with Inheritance:** The inverse; use sparingly when base types are explicitly extensible.
    
-   **Decorator:** Canonical composition for stackable behaviors.
    
-   **Adapter:** Change interface to match client expectations (often coexists with delegation).
    
-   **Facade:** Expose a smaller API over a complex delegate set.
    
-   **Strategy:** Inject swappable behaviors into the wrapper.
    
-   **Extract Interface / Ports & Adapters:** Publish a narrow contract to avoid forwarding huge frameworks.
    

**Rule of thumb:** If you hear “We subclassed X just to tweak Y,” it’s a strong signal to **replace inheritance with delegation**.

You: 

Fill out the following chapters for the Refactoring Pattern "Replace Magic Number With Constant": Pattern Name and Classification, Intent, Also Known As, Motivation (Forces), Applicability, Structure, Participants, Collaboration, Consequences, Implementation, Sample Code, Known Uses, Related Patterns In case code is useful provide a sample code in Java. Start with the pattern name and topic as title. Proceed with the chapters as listed. Do not provide any questions in the end.

ChatGPT: 

Nachgedacht für 8s

# Replace Magic Number with Constant — Refactoring Pattern

## Pattern Name and Classification

**Name:** Replace Magic Number with Constant  
**Classification:** Refactoring Pattern (Readability & Maintainability / Expressive Naming)

## Intent

Replace unexplained numeric literals (e.g., `0.07`, `-1`, `86400`) with **named constants** (or stronger domain types) to make intent explicit, centralize change, and prevent defects.

## Also Known As

-   Replace Literal with Named Constant
    
-   Explain Numeric Literal
    
-   Symbolic Constant
    

## Motivation (Forces)

-   **Readability:** `price * 1.07` vs. `price * (1 + SALES_TAX_RATE)`—the latter explains *why*.
    
-   **Single source of truth:** Changing a rate/threshold in one place, not hunting literals across the codebase.
    
-   **Avoid “coincidental equality”:** Two identical numbers might represent different concepts.
    
-   **Type safety & units:** Seconds vs. milliseconds, percentages vs. multipliers—literals invite unit mistakes.
    
-   **Testing & configuration:** Constants can be overridden in tests/config safely, literals can’t.
    

## Applicability

Apply when you see:

-   **Unexplained numeric literals** used directly in logic or conditions.
    
-   Repeated numbers that **encode a rule** (e.g., min password length, retry limit).
    
-   **Sentinel values** like `-1` for “not found” or “unbounded” (consider `Optional`/null or dedicated type first).
    
-   **Unit-sensitive values** (timeouts, sizes) that should be clear (`Duration.ofSeconds(30)` not `30000`).
    

Avoid or postpone when:

-   The number is **self-evident** and localized (e.g., `i = i + 1` in a loop).
    
-   The concept is still **volatile** and unclear—introduce a name once meaning stabilizes.
    
-   You risk **over-constanting** trivial literals, hurting readability.
    

## Structure

```scss
Before:
total = subtotal * 1.07;             // why 1.07?
if (retries > 3) backoff(5000);      // 5000 ms?

After:
total = subtotal * (1 + SALES_TAX_RATE);
if (retries > MAX_RETRIES) backoff(DEFAULT_BACKOFF.toMillis());
```

## Participants

-   **Named Constant:** `static final` field or enum constant giving semantic meaning and a single definition.
    
-   **Domain Types (optional):** `Duration`, `BigDecimal`, `DataSize`, `Money` that encode unit/scale.
    
-   **Call Sites:** Replace raw literals with the named constant or type.
    

## Collaboration

-   Constants live close to their **domain owner** (class/module) or in a **configuration** component.
    
-   Call sites refer to the constant; tests can **override via DI/config** when appropriate.
    
-   Enums may carry **per-constant parameters** (e.g., regional VAT rates).
    

## Consequences

**Benefits**

-   Self-documenting code; lower cognitive load.
    
-   Centralized change point; less risk of inconsistent updates.
    
-   Fewer unit mistakes (ms vs. s); easier testing.
    

**Liabilities / Trade-offs**

-   Too many constants can clutter namespaces.
    
-   Premature constants for trivial numbers reduce readability.
    
-   Misplaced constants (global “Constants.java”) can create **god modules**; prefer proximity to usage.
    

## Implementation

1.  **Identify Magic Numbers**
    
    -   Search for numeric literals in business logic and conditionals; classify by meaning.
        
2.  **Name the Concept**
    
    -   Choose a **domain name** (e.g., `MAX_RETRIES`, `SALES_TAX_RATE`, `FREE_SHIPPING_THRESHOLD`).
        
3.  **Choose Representation**
    
    -   `static final` for compile-time constants; `Duration`/`BigDecimal`/`DataSize` for units; or **config** for environment-specific values.
        
4.  **Introduce Constant Near Owner**
    
    -   Put it in the class that enforces the rule; avoid catch-all “Constants” dumping ground.
        
5.  **Replace Usages**
    
    -   Update all call sites; ensure no unrelated literals get replaced by accident.
        
6.  **Consider Tests & Config**
    
    -   If the value varies by environment, surface it via configuration/constructor parameters; default constant remains.
        
7.  **Remove Dead Duplication**
    
    -   Delete duplicated literals; keep one authoritative definition.
        

---

## Sample Code (Java)

### 1) Basic replacement: tax rate, retries, and timeouts

**Before**

```java
public class CheckoutService {

  public BigDecimal total(BigDecimal subtotal) {
    return subtotal.multiply(new BigDecimal("1.07")); // 7% tax?
  }

  public void callWithRetry(Runnable op) {
    int attempts = 0;
    while (attempts <= 3) { // why 3?
      try { op.run(); return; }
      catch (Exception e) {
        attempts++;
        try { Thread.sleep(5000); } catch (InterruptedException ignored) {} // ms or s?
      }
    }
    throw new IllegalStateException("failed");
  }
}
```

**After**

```java
public class CheckoutService {

  // Domain-expressive names
  private static final BigDecimal SALES_TAX_RATE = new BigDecimal("0.07");
  private static final int MAX_RETRIES = 3;
  private static final java.time.Duration DEFAULT_BACKOFF = java.time.Duration.ofSeconds(5);

  public BigDecimal total(BigDecimal subtotal) {
    return subtotal.multiply(BigDecimal.ONE.add(SALES_TAX_RATE));
  }

  public void callWithRetry(Runnable op) {
    int attempts = 0;
    while (attempts <= MAX_RETRIES) {
      try { op.run(); return; }
      catch (Exception e) {
        attempts++;
        try { Thread.sleep(DEFAULT_BACKOFF.toMillis()); } catch (InterruptedException ignored) {}
      }
    }
    throw new IllegalStateException("failed");
  }
}
```

### 2) Units & domain types prevent mistakes

**Before**

```java
public class SessionConfig {
  public long ttl = 86400; // seconds? ms? days?
}
```

**After**

```java
public class SessionConfig {
  public static final java.time.Duration DEFAULT_TTL = java.time.Duration.ofDays(1);
}
```

### 3) Sentinel values: replace with constants or better types

**Before**

```java
int findIndex(String s, String[] arr) {
  for (int i = 0; i < arr.length; i++) if (arr[i].equals(s)) return i;
  return -1; // sentinel "not found"
}
```

**After (constant)**

```java
private static final int NOT_FOUND = -1;
int findIndex(String s, String[] arr) {
  for (int i = 0; i < arr.length; i++) if (arr[i].equals(s)) return i;
  return NOT_FOUND;
}
```

**Better (Optional)**

```java
OptionalInt findIndex(String s, String[] arr) {
  for (int i = 0; i < arr.length; i++) if (arr[i].equals(s)) return OptionalInt.of(i);
  return OptionalInt.empty();
}
```

### 4) Regionalized constants via enum (per-constant parameters)

```java
public enum VatRegion {
  AT(new BigDecimal("0.20")),
  DE(new BigDecimal("0.19")),
  CH(new BigDecimal("0.077"));

  public final BigDecimal rate;
  VatRegion(BigDecimal rate) { this.rate = rate; }
}

public class VatCalculator {
  public BigDecimal addVat(BigDecimal net, VatRegion region) {
    return net.multiply(BigDecimal.ONE.add(region.rate));
  }
}
```

### 5) Configuration-backed constants (overridable)

```java
public class PricingConfig {
  private final BigDecimal loyaltyDiscount; // injected

  public static final BigDecimal DEFAULT_LOYALTY_DISCOUNT = new BigDecimal("0.05");

  public PricingConfig(BigDecimal loyaltyDiscount) {
    this.loyaltyDiscount = loyaltyDiscount != null ? loyaltyDiscount : DEFAULT_LOYALTY_DISCOUNT;
  }

  public BigDecimal loyaltyDiscount() { return loyaltyDiscount; }
}
```

---

## Known Uses

-   Replacing `60 * 60 * 24` with `Duration.ofDays(1)` in schedulers and caches.
    
-   Thresholds and limits (e.g., `MAX_UPLOAD_MB`, `PASSWORD_MIN_LENGTH`, `MAX_RETRIES`) across services.
    
-   Monetary rules (VAT, rounding scale) expressed as `BigDecimal` constants in a **Money/Tax** module.
    
-   Bit masks and protocol constants centralized in protocol classes/enums.
    
-   UI layout metrics (spacing, animation durations) in style/theme constants.
    

## Related Patterns

-   **Introduce Parameter Object:** When many related constants travel together per call.
    
-   **Encapsulate Field / Value Object:** Replace primitive constants with rich types (`Money`, `DateRange`).
    
-   **Replace Conditional with Polymorphism:** When constants drive switches; move behavior into variants.
    
-   **Extract Class:** If constants and related behavior suggest a new cohesive module.
    
-   **Replace Type Code with Class/Enum:** When a numeric code represents a category or state.
    
-   **Rename Variable / Self-Documenting Code:** Complements this by naming non-constant locals clearly.
    

**Guideline:** Replace literals that **communicate policy or units**. Keep local arithmetic literals (e.g., `+ 1`, loop increments) inline unless they hide domain meaning.

You: 

Fill out the following chapters for the Refactoring Pattern "Replace Teamp With Query": Pattern Name and Classification, Intent, Also Known As, Motivation (Forces), Applicability, Structure, Participants, Collaboration, Consequences, Implementation, Sample Code, Known Uses, Related Patterns In case code is useful provide a sample code in Java. Start with the pattern name and topic as title. Proceed with the chapters as listed. Do not provide any questions in the end.

ChatGPT: 

# Replace Temp with Query — Refactoring Pattern

## Pattern Name and Classification

**Name:** Replace Temp with Query  
**Classification:** Refactoring Pattern (Expression Simplification / Enable Further Decomposition)

## Intent

Eliminate **temporary variables that store the result of an expression** by replacing them with **query methods** (small, side-effect-free methods). This clarifies intent, reduces local state, and unlocks further refactorings (e.g., *Extract Method*, *Introduce Parameter Object*).

## Also Known As

-   Replace Temporary Variable with Query
    
-   Turn Temp into Getter
    
-   Compute on Demand
    

## Motivation (Forces)

-   **Local state noise:** Temps increase cognitive load and hinder extraction of surrounding code.
    
-   **Duplication:** The same expression is computed and stored in different temps across methods.
    
-   **Encapsulation:** Placing the computation behind a named query communicates **what** over **how**.
    
-   **Testability:** A query is unit-testable; a temp is not directly addressable.
    
-   **Further refactorings:** Fewer temps make it easier to *Decompose Conditional* or move behavior to the right class.
    

Counter-forces:

-   **Performance fears:** Recomputing an expensive expression repeatedly. (Mitigate with caching/memoization if truly needed and measured.)
    
-   **Side effects:** Don’t extract into a query if the original expression has side effects—make it pure first.
    

## Applicability

Apply when:

-   A temp stores a **pure, derivable** value used multiple times in a method.
    
-   A temp blocks *Extract Method* because it ties many statements together.
    
-   The computation belongs conceptually to the **class** (or a collaborator) rather than the method.
    

Avoid when:

-   The expression is **impure** (has side effects) — refactor to purity first.
    
-   The value is **expensive** and used many times in tight loops (measure; then cache).
    
-   The temp is a **loop index** or trivial, hyper-local calculation that improves clarity in place.
    

## Structure

```typescript
Before:
method() {
  var basePrice = quantity * itemPrice;
  if (basePrice > 1000) applyDiscount();
  return basePrice + shipping(basePrice);
}

After:
method() {
  if (basePrice() > 1000) applyDiscount();
  return basePrice() + shipping(basePrice());
}

private int basePrice() { return quantity * itemPrice; }
```

## Participants

-   **Caller Method:** The original method holding temporary variables.
    
-   **Query Method(s):** Side-effect-free methods that compute derived values on demand.
    
-   **Owning Class or Collaborator:** Where the query naturally belongs (domain owner of the data).
    

## Collaboration

-   The caller **invokes queries** instead of reading temps.
    
-   Multiple methods can **reuse** the same query.
    
-   If queries rely on collaborators (e.g., repository, policy), pass those in or move the query to the collaborator (*Move Method*).
    

## Consequences

**Benefits**

-   Clearer intent and simpler methods; fewer locals.
    
-   Reuse across the class; one place to change the computation.
    
-   Enables further refactorings (extract/inline/move).
    
-   Improves testability via focused unit tests.
    

**Liabilities / Trade-offs**

-   Potential recomputation overhead (rarely significant; cache if needed).
    
-   Too many tiny queries can fragment code—favor meaningful names and cohesion.
    
-   If the query reaches across boundaries, you may increase coupling (consider *Move Method*).
    

## Implementation

1.  **Verify Purity**
    
    -   Ensure the temp’s expression is side-effect-free and deterministic for the method’s scope.
        
2.  **Create a Query**
    
    -   Extract a private method with an intention-revealing name; pass required inputs or use fields.
        
3.  **Replace Temp Uses**
    
    -   Substitute all references to the temp with the query call.
        
4.  **Remove the Temp**
    
    -   Delete the temporary variable. Compile and run tests.
        
5.  **Consider Placement**
    
    -   If the query conceptually belongs elsewhere, *Move Method* to that class.
        
6.  **Optimize When Proven**
    
    -   If profiling shows cost, add memoization (lazy field) or compute once and pass down explicitly.
        

---

## Sample Code (Java)

### 1) Basic replacement to clarify intent

**Before**

```java
public class Order {
  private final int quantity;
  private final BigDecimal itemPrice;

  public Order(int quantity, BigDecimal itemPrice) {
    this.quantity = quantity;
    this.itemPrice = itemPrice;
  }

  public BigDecimal total() {
    BigDecimal basePrice = itemPrice.multiply(BigDecimal.valueOf(quantity));
    BigDecimal discount = basePrice.compareTo(new BigDecimal("1000")) > 0
        ? basePrice.multiply(new BigDecimal("0.05"))
        : BigDecimal.ZERO;
    BigDecimal shipping = basePrice.compareTo(new BigDecimal("500")) > 0
        ? new BigDecimal("0")
        : new BigDecimal("20");
    return basePrice.subtract(discount).add(shipping);
  }
}
```

**After (Replace Temp with Query)**

```java
public class Order {
  private final int quantity;
  private final BigDecimal itemPrice;

  public Order(int quantity, BigDecimal itemPrice) {
    this.quantity = quantity;
    this.itemPrice = itemPrice;
  }

  public BigDecimal total() {
    return basePrice()
        .subtract(discount())
        .add(shipping());
  }

  /** Pure queries (no side effects) */
  private BigDecimal basePrice() {
    return itemPrice.multiply(BigDecimal.valueOf(quantity));
  }

  private BigDecimal discount() {
    return basePrice().compareTo(new BigDecimal("1000")) > 0
        ? basePrice().multiply(new BigDecimal("0.05"))
        : BigDecimal.ZERO;
  }

  private BigDecimal shipping() {
    return basePrice().compareTo(new BigDecimal("500")) > 0
        ? BigDecimal.ZERO
        : new BigDecimal("20");
  }
}
```

### 2) Avoid recomputation via a memoized query (only if measured)

```java
public class Order {
  private final int quantity;
  private final BigDecimal itemPrice;
  private BigDecimal cachedBasePrice; // lazily computed

  private BigDecimal basePrice() {
    if (cachedBasePrice == null) {
      cachedBasePrice = itemPrice.multiply(BigDecimal.valueOf(quantity));
    }
    return cachedBasePrice;
  }
}
```

### 3) Moving the query to the natural owner (*Move Method* synergy)

```java
public class ShoppingCart {
  private final List<CartLine> lines;

  public BigDecimal total() {
    return subtotal().add(tax());
  }

  private BigDecimal subtotal() {
    return lines.stream().map(CartLine::lineTotal).reduce(BigDecimal.ZERO, BigDecimal::add);
  }

  private BigDecimal tax() {
    return subtotal().multiply(new BigDecimal("0.20"));
  }
}

public record CartLine(BigDecimal unitPrice, int qty) {
  // replacing temps in callers with a query on the correct owner
  public BigDecimal lineTotal() { return unitPrice.multiply(BigDecimal.valueOf(qty)); }
}
```

### 4) Enabling further refactoring (Decompose Conditional)

```java
public class FareService {
  public BigDecimal price(Trip t) {
    if (isPeak(t)) return peakPrice(t.distanceKm());
    return offPeakPrice(t.distanceKm());
  }

  private boolean isPeak(Trip t) {
    return peakWindow().contains(t.departure());
  }

  private TimeWindow peakWindow() { /* replaces temps with a clear query */ return TimeWindow.weekdayRushHours(); }
  private BigDecimal peakPrice(int km) { /* ... */ return BigDecimal.TEN; }
  private BigDecimal offPeakPrice(int km) { /* ... */ return BigDecimal.ONE; }
}
```

---

## Known Uses

-   Replacing repeated local temps for **subtotal**, **base price**, **tax**, **discount**, **distance**, or **normalized strings** with named queries.
    
-   Cleaning up controller/service methods so queries live on **domain entities** or **value objects** instead of temporary locals.
    
-   Pre-step for **Replace Conditional with Polymorphism**—queries isolate branch predicates.
    

## Related Patterns

-   **Extract Method:** Often the mechanical step to create the query.
    
-   **Introduce Explaining Variable:** The opposite move when a short-lived, clearly named temp helps readability; choose case-by-case.
    
-   **Move Method:** After extraction, move the query to the class that owns the data.
    
-   **Inline Temp:** When a temp is truly trivial, inline it directly instead of extracting.
    
-   **Replace Method with Method Object:** For very long methods where many temps become fields of a helper object.
    
-   **Encapsulate Field / Value Object:** Strengthen queries by pushing them into richer types (e.g., `Money`, `DateRange`).

You: 

Fill out the following chapters for the Refactoring Pattern "Simplify Nested Conditional": Pattern Name and Classification, Intent, Also Known As, Motivation (Forces), Applicability, Structure, Participants, Collaboration, Consequences, Implementation, Sample Code, Known Uses, Related Patterns In case code is useful provide a sample code in Java. Start with the pattern name and topic as title. Proceed with the chapters as listed. Do not provide any questions in the end.

ChatGPT: 

Nachgedacht für 6s

# Simplify Nested Conditional — Refactoring Pattern

## Pattern Name and Classification

**Name:** Simplify Nested Conditional  
**Classification:** Refactoring Pattern (Control-Flow Simplification / Readability & Maintainability)

## Intent

Flatten deeply nested `if/else` blocks to make the **happy path obvious** and exceptional or edge cases explicit. Use **guard clauses**, **early returns**, and **extracted predicates** so the method reads as a straightforward decision narrative.

## Also Known As

-   Replace Nested Conditional with Guard Clauses
    
-   Flatten Conditionals
    
-   Early Return / Fail Fast
    
-   De-nest Conditionals
    

## Motivation (Forces)

-   **Cognitive load:** Deep indentation hides the main intent and interleaves concerns.
    
-   **Error-proneness:** It’s easy to miss an `else` branch or invert logic by mistake.
    
-   **Testing friction:** Hard to isolate edge cases when the happy path is buried.
    
-   **Change amplification:** Adding a new rule requires threading through multiple nested levels.
    
-   **Readability:** Linear, guard-first methods are easier to scan and maintain.
    

## Applicability

Apply when you see:

-   Multiple levels of nested `if/else` guarding preconditions, errors, or special cases.
    
-   Early error checks hidden *inside* the main logic instead of up front.
    
-   Compound predicates in-line that could be **named** and reused (e.g., `isBlackout(date)`).
    
-   A method that “pyramids of doom” (ever-increasing indentation).
    

Avoid or defer when:

-   You must perform **mandatory cleanup** before returning (use `try-with-resources` / `finally`).
    
-   The logic is **truly sequential** and early returns would obscure required steps.
    
-   You’re in a **public API** that mandates a single exit for tracing—still possible, but use local helpers to clarify.
    

## Structure

```scss
Before (pyramid):
method() {
  if (preconditionA) {
    if (preconditionB) {
      // happy path buried
      doMainWork();
    } else {
      handleBFailure();
    }
  } else {
    handleAFailure();
  }
}

After (flat with guards):
method() {
  if (!preconditionA) return handleAFailure();
  if (!preconditionB) return handleBFailure();
  return doMainWork();
}
```

## Participants

-   **Orchestrating Method:** Hosts the decision flow.
    
-   **Guard Clauses:** Early checks that exit on invalid/edge scenarios.
    
-   **Predicate Methods:** Small, pure boolean queries expressing business rules.
    
-   **Action Methods:** Intention-revealing methods for each outcome.
    

## Collaboration

-   Predicates expose **domain language** (e.g., `isVip`, `isPeak`), which the orchestrator composes.
    
-   Guard clauses **short-circuit** edge cases, keeping the happy path linear.
    
-   Extracted actions encapsulate side effects and enable reuse.
    

## Consequences

**Benefits**

-   Flatter, more readable code; the **happy path is obvious**.
    
-   Fewer branches to reason about; lower bug surface.
    
-   Easier unit testing of predicates and actions in isolation.
    
-   Enables further refactorings (Replace Conditional with Polymorphism, Strategy, Specification).
    

**Liabilities / Trade-offs**

-   Multiple return points can complicate debugging in some contexts (usually outweighed by clarity).
    
-   Overuse of early returns without naming can still be cryptic—**good names matter**.
    
-   If cleanup is required, must ensure it always runs (use structured resources).
    

## Implementation

1.  **Identify Guard Candidates**
    
    -   Preconditions, null checks, authorization failures, unsupported states → move to **top** as early exits.
        
2.  **Extract Predicates**
    
    -   Convert complex boolean expressions into **well-named methods** (pure).
        
3.  **Introduce Guard Clauses**
    
    -   Replace outer `if (ok) { … } else { fail }` with `if (!ok) return fail;`.
        
4.  **Extract Actions**
    
    -   Pull branch bodies into methods with intention-revealing names.
        
5.  **Flatten Remaining Conditionals**
    
    -   Repeat until the main flow is linear.
        
6.  **Consider Strategy/Polymorphism**
    
    -   If the remaining conditional varies by type/state, move to polymorphism.
        
7.  **Test Thoroughly**
    
    -   Unit-test predicates and each guard; keep an integration test for the orchestrator.
        

---

## Sample Code (Java)

### Before — Deeply nested conditionals

```java
public class BookingService {

  public Reservation book(BookingRequest req, User user, Inventory inventory) {
    if (req != null) {
      if (user != null) {
        if (user.hasPermission("BOOK")) {
          if (!inventory.isSoldOut(req.date(), req.roomType())) {
            if (!req.date().isBefore(java.time.LocalDate.now())) {
              // happy path buried deep
              Reservation r = inventory.reserve(req.roomType(), req.date(), req.nights());
              if (r != null) {
                return r;
              } else {
                return Reservation.rejected("Reservation failed");
              }
            } else {
              return Reservation.rejected("Date in the past");
            }
          } else {
            return Reservation.rejected("Sold out");
          }
        } else {
          return Reservation.rejected("Not authorized");
        }
      } else {
        return Reservation.rejected("Missing user");
      }
    } else {
      return Reservation.rejected("Missing request");
    }
  }
}
```

### After — Guard clauses, extracted predicates, linear happy path

```java
public class BookingService {

  public Reservation book(BookingRequest req, User user, Inventory inventory) {
    if (req == null)              return reject("Missing request");
    if (user == null)             return reject("Missing user");
    if (!user.hasPermission("BOOK")) return reject("Not authorized");
    if (isPast(req.date()))       return reject("Date in the past");
    if (isSoldOut(inventory, req)) return reject("Sold out");

    return tryReserve(inventory, req);
  }

  // --- predicates (pure, intention-revealing) ---
  private boolean isPast(LocalDate date) {
    return date.isBefore(LocalDate.now());
  }

  private boolean isSoldOut(Inventory inv, BookingRequest req) {
    return inv.isSoldOut(req.date(), req.roomType());
  }

  // --- actions ---
  private Reservation tryReserve(Inventory inv, BookingRequest req) {
    Reservation r = inv.reserve(req.roomType(), req.date(), req.nights());
    return (r != null) ? r : reject("Reservation failed");
  }

  private Reservation reject(String reason) {
    return Reservation.rejected(reason);
  }
}
```

### Variant — Guard clauses with mandatory cleanup (try-with-resources)

```java
public class ReportService {

  public byte[] generate(ReportSpec spec, DataSource ds) throws IOException {
    if (spec == null) throw new IllegalArgumentException("spec");
    if (!spec.isValid()) return fail("Invalid spec");

    try (var conn = ds.getConnection();
         var out = new java.io.ByteArrayOutputStream()) {

      if (!hasAccess(spec)) return fail("Forbidden");
      writeReport(spec, conn, out);     // happy path
      return out.toByteArray();
    }
  }

  private byte[] fail(String msg) { throw new IllegalStateException(msg); }
}
```

### Variant — Decompose nested conditions, then polymorphism

```java
public class ShippingCostService {

  public BigDecimal cost(Order order) {
    if (!order.isDomestic()) return internationalPricing().price(order);
    if (order.weightKg() > 20) return heavyDomesticPricing().price(order);
    return standardDomesticPricing().price(order);
  }

  private PricingStrategy internationalPricing() { return new InternationalPricing(); }
  private PricingStrategy heavyDomesticPricing() { return new HeavyDomesticPricing(); }
  private PricingStrategy standardDomesticPricing() { return new StandardDomesticPricing(); }
}
```

---

## Known Uses

-   Authorization and validation at the **top** of controller/service methods (“fail fast”).
    
-   Pricing, shipping, or eligibility rules where many exceptions collapse into **named predicates**.
    
-   Legacy “pyramid” methods as a **first step** before introducing Strategy/State.
    
-   Handling **null/optional** inputs upfront, returning early or throwing with clear messages.
    

## Related Patterns

-   **Guard Clauses:** Core technique to exit early and flatten nesting.
    
-   **Decompose Conditional / Extract Method:** Used to separate predicates and actions.
    
-   **Replace Conditional with Polymorphism:** When a single axis (type/state) drives branching after flattening.
    
-   **Introduce Parameter Object:** Bundle inputs that travel through many predicates.
    
-   **Replace Temp with Query:** Remove temps to enable extraction of predicates.
    
-   **Strategy / Specification:** Model rule sets or composable business predicates once simplified.
    

**Guideline:** Put **error/edge checks first**, name your **predicates**, keep the **happy path straight**.

You: 

Fill out the following chapters for the Refactoring Pattern "Split Variable": Pattern Name and Classification, Intent, Also Known As, Motivation (Forces), Applicability, Structure, Participants, Collaboration, Consequences, Implementation, Sample Code, Known Uses, Related Patterns In case code is useful provide a sample code in Java. Start with the pattern name and topic as title. Proceed with the chapters as listed. Do not provide any questions in the end.

ChatGPT: 

Nachgedacht für 22s

# Split Variable — Refactoring Pattern

## Pattern Name and Classification

**Name:** Split Variable  
**Classification:** Refactoring Pattern (State Clarification / Readability & Correctness)

## Intent

Replace a **single variable that represents multiple concepts over time** (reassigned to different meanings) with **separate, well-named variables**—ideally `final`—so each variable has exactly **one responsibility** and a minimal scope.

## Also Known As

-   Single-Assignment Variables
    
-   One Variable, One Meaning
    
-   Eliminate Temporal Coupling in Locals
    

## Motivation (Forces)

-   **Temporal coupling:** A variable is reassigned to hold different concepts (e.g., first “circumference,” later “area”).
    
-   **Bugs from reuse:** Later code accidentally uses an earlier value (or vice versa).
    
-   **Readability:** Future readers must keep a timeline in their head to know what a variable “currently” means.
    
-   **Optimization temptation:** Reuse “to save memory” is pointless noise in modern languages and hurts clarity.
    
-   **Refactoring friction:** Mixed meanings block *Extract Method*, *Introduce Explaining Variable*, and testing.
    

## Applicability

Apply when:

-   A local variable is **assigned more than once** and those assignments **represent different concepts**.
    
-   A loop variable is reused as an **accumulator** or vice versa.
    
-   A method uses the same name for **input normalization** and later **computation results**.
    
-   A try block assigns to a variable and a catch/finally block **reuses it for another purpose**.
    

Avoid or postpone when:

-   Reassignments are truly **iterative updates of the same concept** (e.g., an accumulator inside a fold).
    
-   The variable’s meaning is stable and renaming suffices (use *Rename Variable*).
    
-   Extremely tight, performance-critical code where extra locals measurably hurt (rare; measure first).
    

## Structure

```cpp
Before:
double temp = 2 * PI * r;   // circumference
...
temp = PI * r * r;          // area (same variable, new meaning)

After:
final double circumference = 2 * PI * r;
...
final double area = PI * r * r;
```

## Participants

-   **Confused Local:** The original multi-purpose variable.
    
-   **Meaningful Locals:** New variables, each bound to one concept, preferably `final` and minimally scoped.
    
-   **Callers/Readers:** Benefit from explicit names and stable meanings.
    

## Collaboration

-   Each meaning is **named and isolated**, enabling further refactorings (e.g., extracting `area()` and `circumference()` queries).
    
-   Tests and reviewers reason about values **without tracking temporal state**.
    

## Consequences

**Benefits**

-   Eliminates a class of subtle bugs from **stale or overwritten values**.
    
-   Improves readability and intent; simplifies extraction and testing.
    
-   Encourages **single-assignment**, functional style and smaller scopes.
    

**Liabilities / Trade-offs**

-   Slight increase in the number of locals.
    
-   Overzealous splitting can add noise—use **good names and minimal scope**.
    

## Implementation

1.  **Identify distinct meanings** of the reassigned variable.
    
2.  **Introduce a new variable per meaning**; name by domain concept.
    
3.  **Make them `final`** where possible; **narrow scope** to the smallest block that uses them.
    
4.  **Replace each use** of the old variable with the appropriate new one.
    
5.  **Re-run tests**; then consider *Extract Method* or *Replace Temp with Query* for derived values.
    
6.  **Clean up loops**: if a variable serves as both index and accumulator, **separate** them (or use stream/fold).
    

---

## Sample Code (Java)

### 1) Business logic: totals vs. shipping (before → after)

**Before (one variable, multiple meanings)**

```java
public BigDecimal checkoutTotal(Order order) {
  BigDecimal value = order.items().stream()
      .map(li -> li.unitPrice().multiply(BigDecimal.valueOf(li.qty())))
      .reduce(BigDecimal.ZERO, BigDecimal::add); // value = subtotal

  if (order.hasCoupon()) {
    value = value.multiply(new BigDecimal("0.90")); // now value = discounted total
  }

  // Reusing the same variable for shipping cost (different concept!)
  value = order.weightKg().compareTo(new BigDecimal("5")) > 0
      ? new BigDecimal("12.00")
      : new BigDecimal("4.90"); // now value = shipping

  // Oops—what are we adding here?
  return order.subtotal() // stale API call; developer confusion starts
      .add(value);
}
```

**After (split variables, single meaning each)**

```java
public BigDecimal checkoutTotal(Order order) {
  final BigDecimal subtotal = order.items().stream()
      .map(li -> li.unitPrice().multiply(BigDecimal.valueOf(li.qty())))
      .reduce(BigDecimal.ZERO, BigDecimal::add);

  final BigDecimal discountedTotal = order.hasCoupon()
      ? subtotal.multiply(new BigDecimal("0.90"))
      : subtotal;

  final BigDecimal shipping = order.weightKg().compareTo(new BigDecimal("5")) > 0
      ? new BigDecimal("12.00")
      : new BigDecimal("4.90");

  return discountedTotal.add(shipping);
}
```

### 2) Geometry example (classic)

**Before**

```java
double temp = 2 * Math.PI * radius;  // circumference
log(temp);
temp = Math.PI * radius * radius;    // area
return temp;
```

**After**

```java
final double circumference = 2 * Math.PI * radius;
log(circumference);
final double area = Math.PI * radius * radius;
return area;
```

### 3) Loop index vs. accumulator

**Before**

```java
int i = 0;
for (i = 0; i < lines.size(); i++) {
  i += lines.get(i).cost(); // mixing index and accumulator!
}
return i;
```

**After**

```java
int totalCost = 0;
for (int idx = 0; idx < lines.size(); idx++) {
  totalCost += lines.get(idx).cost();
}
return totalCost;
```

### 4) With streams, temps often become queries (bonus synergy)

```java
public BigDecimal invoiceTotal(List<Line> lines) {
  final BigDecimal subtotal = lines.stream()
      .map(l -> l.price().multiply(BigDecimal.valueOf(l.qty())))
      .reduce(BigDecimal.ZERO, BigDecimal::add);

  final BigDecimal tax = subtotal.multiply(new BigDecimal("0.20"));
  return subtotal.add(tax);
}
```

---

## Known Uses

-   Financial computations where a “`result`” variable flips between **subtotal**, **discounted**, and **shipping**.
    
-   Parsing/validation code that reuses `str` for both **raw input** and **sanitized/normalized** form.
    
-   Algorithmic code reusing a single variable as **loop index** and **accumulator**.
    
-   Scientific/graphics computations where `t` stands for **time** then gets reused as **temporary**.
    

## Related Patterns

-   **Replace Temp with Query:** Turn derived values into side-effect-free methods.
    
-   **Introduce Explaining Variable:** Add a named local for a complex expression (when one meaning).
    
-   **Rename Variable:** If meaning is consistent but unclear.
    
-   **Extract Method:** After splitting, extract cohesive computations.
    
-   **Split Loop:** If a loop performs two different tasks, separate loops for clarity and correctness.
    
-   **Encapsulate Variable / Encapsulate Field:** When the “variable” is a field shared across methods; move and protect it.

You: 

Fill out the following chapters for the Resillience, Fault Tolerance Pattern "Bulkhead": Pattern Name and Classification, Intent, Also Known As, Motivation (Forces), Applicability, Structure, Participants, Collaboration, Consequences, Implementation, Sample Code, Known Uses, Related Patterns In case code is useful provide a sample code in Java. Start with the pattern name and topic as title. Proceed with the chapters as listed. Do not provide any questions in the end.

ChatGPT: 

# Bulkhead — Resilience & Fault-Tolerance Pattern

## Pattern Name and Classification

**Name:** Bulkhead  
**Classification:** Resilience / Fault-Tolerance Pattern (Isolation & Containment)

## Intent

Prevent a failure or resource spike in one part of the system from **cascading** into others by **partitioning resources** (threads, connection pools, queues, rate budgets) into isolated compartments (“bulkheads”).

## Also Known As

-   Resource Partitioning
    
-   Isolation Pools
    
-   Compartmentalization
    
-   Concurrency Limits per Dependency
    

## Motivation (Forces)

-   **Noisy neighbor risk:** One slow or failing dependency can exhaust shared resources (threads, sockets) and stall unrelated work.
    
-   **Backpressure & fairness:** High-priority flows need guarantees even when low-priority traffic spikes.
    
-   **Predictability:** SLOs require caps on concurrency and clear failure modes instead of queue pile-ups.
    
-   **Graceful degradation:** Prefer “fail fast here” over “everything times out everywhere.”
    

## Applicability

Use Bulkheads when:

-   A service calls **multiple downstreams** with different criticality levels.
    
-   Workloads have **distinct priorities** (e.g., user-facing vs. batch).
    
-   You observed **thread/connection starvation**, queue build-ups, or GC pressure during partial outages.
    
-   You run **multi-tenant** workloads that must not affect each other.
    

Avoid or use lightly when:

-   System is **tiny** with a single dependency and over-isolation adds operational overhead.
    
-   Strict isolation would **waste scarce resources** (tiny instances); consider dynamic partitioning.
    

## Structure

```sql
┌───────────────────────────── Service ─────────────────────────────┐
                 │                                                                    │
   User APIs ───►│ Pool A (32 threads) ──► Downstream X                               │
 Batch Jobs ───► │ Pool B (8 threads)  ──► Downstream Y                               │
  Admin Ops ───► │ Pool C (4 threads)  ──► Local CPU task                             │
                 │   ^  timeouts, fallback, metrics                                   │
                 └───┴────────────────────────────────────────────────────────────────┘

Alternative: semaphore bulkheads per call-site (limit in-flight calls per dependency).
```

## Participants

-   **Caller / Orchestrator:** Routes work to the correct bulkhead.
    
-   **Bulkhead:** The isolation mechanism (thread pool / executor, semaphore, queue, connection pool).
    
-   **Downstream / Task:** The work that may fail or stall.
    
-   **Fallback / Degrader:** Optional path when the bulkhead is saturated (defaults, cached data).
    

## Collaboration

-   Caller chooses bulkhead based on **priority or dependency**.
    
-   Bulkhead **accepts or rejects** work (fast failure) and enforces concurrency and queue limits.
    
-   Fallback provides **graceful degradation** when bulkhead rejects.
    

## Consequences

**Benefits**

-   Containment of faults; **no cascade** from one dependency to all traffic.
    
-   **Predictable latency** for critical flows.
    
-   Enforced backpressure; easier capacity planning and SLOs.
    
-   Clear signals (rejections) that trigger autoscaling or shed load.
    

**Liabilities / Trade-offs**

-   Potential **under-utilization** if partitions are too small or static.
    
-   More **operational tuning** (pool sizes, queue lengths).
    
-   Wrong routing/partitioning can still starve important work.
    
-   Added complexity coordinating with **timeouts, retries, circuit breakers**.
    

## Implementation

1.  **Segment workloads/dependencies.** Decide isolation keys (dependency, priority, tenant).
    
2.  **Choose a mechanism.**
    
    -   **Thread-pool bulkhead:** Fixed (or bounded) pool + bounded queue.
        
    -   **Semaphore bulkhead:** Limit in-flight calls without dedicated threads.
        
    -   **Connection pool partitioning:** Separate pools per dependency/tenant.
        
3.  **Set limits & queues.** Prefer **bounded queues**; avoid unbounded growth.
    
4.  **Integrate with timeouts & retries.** Use short timeouts; retries must respect bulkhead capacity and jitter.
    
5.  **Provide fallbacks.** Cached data, default responses, partial rendering.
    
6.  **Observe & tune.** Export metrics: in-flight, queue depth, rejections, latency percentiles.
    
7.  **Automate scaling/shift.** Adjust partitions by config; support surge modes if needed.
    

---

## Sample Code (Java)

### A) Semaphore Bulkhead per Dependency (lightweight, no extra threads)

```java
import java.time.Duration;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.CompletableFuture;

public class Bulkheads {
  private final Semaphore customerApiSlots = new Semaphore(20); // max in-flight
  private final Semaphore paymentApiSlots  = new Semaphore(8);

  public <T> T withSemaphore(Semaphore sem, Duration timeout, CheckedSupplier<T> task, CheckedSupplier<T> fallback) throws Exception {
    if (!sem.tryAcquire()) return fallback.get(); // fast-fail/fallback when saturated
    try {
      // Run on caller's thread; add explicit timeout
      CompletableFuture<T> f = CompletableFuture.supplyAsync(() -> {
        try { return task.get(); } catch (Exception e) { throw new RuntimeException(e); }
      });
      return f.orTimeout(timeout.toMillis(), java.util.concurrent.TimeUnit.MILLISECONDS).join();
    } catch (java.util.concurrent.CompletionException ce) {
      if (ce.getCause() instanceof java.util.concurrent.TimeoutException) throw new TimeoutException();
      throw (ce.getCause() instanceof Exception e) ? e : new RuntimeException(ce.getCause());
    } finally {
      sem.release();
    }
  }

  public String fetchCustomer(String id, HttpClientAdapter client) throws Exception {
    return withSemaphore(customerApiSlots, Duration.ofMillis(500),
        () -> client.get("/customers/" + id),
        () -> "{}" // minimal fallback
    );
  }

  public String charge(String payload, HttpClientAdapter client) throws Exception {
    return withSemaphore(paymentApiSlots, Duration.ofMillis(800),
        () -> client.post("/payments", payload),
        () -> { throw new IllegalStateException("payment unavailable"); }
    );
  }

  @FunctionalInterface interface CheckedSupplier<T> { T get() throws Exception; }
  interface HttpClientAdapter { String get(String path) throws Exception; String post(String path, String body) throws Exception; }
}
```

### B) Thread-Pool Bulkheads (per-route isolation with bounded queues)

```java
import java.util.concurrent.*;

public class IsolatedExecutors {
  // Distinct pools with bounded queues; saturation triggers RejectedExecutionException
  private final ExecutorService userPool  = new ThreadPoolExecutor(32, 32, 0, TimeUnit.SECONDS,
      new ArrayBlockingQueue<>(64), new ThreadPoolExecutor.AbortPolicy()); // fail fast
  private final ExecutorService batchPool = new ThreadPoolExecutor(8, 8, 0, TimeUnit.SECONDS,
      new ArrayBlockingQueue<>(16), new ThreadPoolExecutor.CallerRunsPolicy()); // natural backpressure

  public <T> T runUserTask(Callable<T> c, long timeoutMs) throws Exception {
    Future<T> f = userPool.submit(c);
    try { return f.get(timeoutMs, TimeUnit.MILLISECONDS); }
    catch (TimeoutException te) { f.cancel(true); throw te; }
  }

  public <T> T runBatchTask(Callable<T> c, long timeoutMs) throws Exception {
    Future<T> f = batchPool.submit(c);
    try { return f.get(timeoutMs, TimeUnit.MILLISECONDS); }
    catch (TimeoutException te) { f.cancel(true); throw te; }
  }

  public void shutdown() { userPool.shutdown(); batchPool.shutdown(); }
}
```

### C) Combining with Circuit Breaker & Retry (outline)

-   **Order of operations at call-site:** `Bulkhead ➜ Timeout ➜ CircuitBreaker ➜ Retry`.
    
-   Retries must **not** exceed bulkhead capacity; add jitter and caps.
    

---

## Known Uses

-   **Isolation per downstream** in microservices (e.g., separate pools for Auth, Payments, Catalog).
    
-   **Priority lanes**: interactive user traffic vs. analytics/batch.
    
-   **Tenant isolation** in multi-tenant SaaS (per-tenant semaphores/quotas).
    
-   **Cloud platform guidance**: bulkheads referenced alongside circuit breakers, retries, and timeouts in many production architectures.
    

## Related Patterns

-   **Circuit Breaker:** Trip when a dependency is failing; bulkhead prevents resource exhaustion while the breaker opens.
    
-   **Timeouts:** Ensure stuck calls don’t hold capacity indefinitely.
    
-   **Retry with Backoff & Jitter:** Retry responsibly; respect bulkhead limits.
    
-   **Load Shedding / Rate Limiting:** Complementary admission control before work reaches bulkheads.
    
-   **Queue-based Load Leveling:** Buffer and decouple producers from consumers (another isolation form).
    
-   **Fallback / Graceful Degradation:** What to do when the bulkhead rejects.
    

**Practical tip:** Start simple with **semaphore bulkheads per dependency**, measure rejections/latency, then introduce specialized thread pools only where you need strict isolation or CPU-bound parallelism.

You: 

Fill out the following chapters for the Resillience, Fault Tolerance Pattern "Circuit Breaker": Pattern Name and Classification, Intent, Also Known As, Motivation (Forces), Applicability, Structure, Participants, Collaboration, Consequences, Implementation, Sample Code, Known Uses, Related Patterns In case code is useful provide a sample code in Java. Start with the pattern name and topic as title. Proceed with the chapters as listed. Do not provide any questions in the end.

ChatGPT: 

Nachgedacht für 12s

# Circuit Breaker — Resilience & Fault-Tolerance Pattern

## Pattern Name and Classification

**Name:** Circuit Breaker  
**Classification:** Resilience / Fault-Tolerance Pattern (Failure Detection & Isolation)

## Intent

Protect a caller from repeatedly invoking a **failing or slow dependency** by **short-circuiting** calls after failures cross a threshold. The breaker transitions among **Closed → Open → Half-Open** to allow recovery probes while preventing cascades.

## Also Known As

-   Automatic Fault Tripper
    
-   Fail-Fast Guard
    
-   Trip/Reset Switch
    

## Motivation (Forces)

-   **Fail fast vs. pile-ups:** Persistent timeouts stack up and saturate threads and connection pools.
    
-   **Backpressure:** We need a clear “stop calling” signal to avoid amplifying downstream outages.
    
-   **Self-healing:** After a cooldown, send limited probes to see if the dependency recovered.
    
-   **Observability:** Centralize failure accounting and expose **clear metrics** to operators.
    

## Applicability

Use Circuit Breaker when:

-   A client calls **remote services** (HTTP/DB/MQ) that can become unavailable or slow.
    
-   You’ve seen **retry storms**, thread starvation, or long tail latencies during incidents.
    
-   You can provide **fallbacks** (cached/partial data) or user-visible degradation.
    

Avoid or be cautious when:

-   Calls are **idempotent and ultra-cheap** and failures are rare—overhead may not pay off.
    
-   There’s **no acceptable fallback** and failing fast is worse than waiting (batch one-offs).
    
-   Errors are **client-side** and should be fixed at source (e.g., invalid request schema).
    

## Structure

```pgsql
┌───────────────┐  success/failure  ┌───────────────┐
            │   CLOSED      │ ─────────────────► │   OPEN        │
  calls go  │ count errors  │  threshold met     │ fail fast     │
  through   │ pass traffic  │  -> trip           │ cooldown timer│
            └──────▲────────┘                    └───────┬───────┘
                   │                                     │ cooldown elapsed
                   │                                     ▼
                   │                              ┌───────────────┐
                   └──────────────────────────────│  HALF-OPEN    │
                                  limited probes  │ allow N probes│
                                                  └───────▲───────┘
                                                          │
                                         success probes -> │ reset to CLOSED
                                         failure probe  -> │ trip to OPEN
```

## Participants

-   **Circuit Breaker:** Tracks state, counts failures/successes, decides to pass/short-circuit calls.
    
-   **Caller:** Wraps dependency calls with the breaker.
    
-   **Dependency:** Remote service or component that may fail/timeout.
    
-   **Fallback / Degrader:** Optional path when breaker blocks calls.
    
-   **Timers & Metrics:** Measure cooldowns, error rates, and state transitions.
    

## Collaboration

-   Caller executes `breaker.call(task, fallback)` (or similar).
    
-   Breaker **rejects** calls immediately in **OPEN**; allows limited **HALF-OPEN** probes.
    
-   Outcome of probes **drives state**; metrics/alerts inform autoscaling and SRE response.
    
-   Often combined with **Bulkhead** (isolation), **Timeout** (don’t hold capacity), and **Retry with backoff** (but only when breaker is allowing traffic).
    

## Consequences

**Benefits**

-   **Containment:** Prevents cascades and thread/connection exhaustion.
    
-   **Predictability:** Fails fast with clear errors during downstream outages.
    
-   **Recovery:** Automatic probing avoids manual intervention.
    
-   **Operability:** Centralized metrics and state transitions.
    

**Liabilities / Trade-offs**

-   **Tuning required:** Poor thresholds can flap or trip too eagerly.
    
-   **Statefulness:** Requires clock/time coordination in distributed systems.
    
-   **False positives:** Client-side bugs can trip breakers; root cause must be addressed.
    
-   **Overhead:** Small latency/complexity per call (usually negligible compared to network I/O).
    

## Implementation

1.  **Choose trigger logic:** Count-based (N failures in window) or **error-rate** over sliding window; include **timeouts** as failures.
    
2.  **Define windows & limits:** e.g., 50% failures over 20 calls; cooldown (open) duration; **half-open probe quota**.
    
3.  **Decide trip causes:** Exceptions, HTTP 5xx, timeouts; optionally **slow-call** thresholds.
    
4.  **Implement states:** Closed (pass), Open (reject), Half-Open (limited probes).
    
5.  **Add fallbacks:** Stale cache, defaults, or user-facing “degraded mode.”
    
6.  **Expose metrics & events:** State, failure rate, rejections, probe outcomes, latency.
    
7.  **Compose with other guards:** Generally: **Bulkhead → Timeout → CircuitBreaker → Retry** (retry only if breaker lets the call through).
    
8.  **Tune & test chaos:** Load test, inject faults, verify rejection rates and recovery behavior.
    

---

## Sample Code (Java)

*A compact, thread-safe, count-based circuit breaker with cooldown and half-open probes.*

```java
import java.time.Duration;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Supplier;

public class CircuitBreaker {

  public enum State { CLOSED, OPEN, HALF_OPEN }

  // Config
  private final int failureThreshold;          // e.g., 5 consecutive failures
  private final Duration openCooldown;         // e.g., 10s
  private final int halfOpenMaxCalls;          // e.g., 3 probes

  // State
  private final AtomicReference<State> state = new AtomicReference<>(State.CLOSED);
  private final AtomicInteger consecutiveFailures = new AtomicInteger(0);
  private final AtomicLong openedAt = new AtomicLong(0);
  private final AtomicInteger halfOpenInFlight = new AtomicInteger(0);

  public CircuitBreaker(int failureThreshold, Duration openCooldown, int halfOpenMaxCalls) {
    this.failureThreshold = failureThreshold;
    this.openCooldown = openCooldown;
    this.halfOpenMaxCalls = halfOpenMaxCalls;
  }

  public <T> T call(CheckedSupplier<T> supplier, Supplier<T> fallback) throws Exception {
    State s = currentState();
    if (s == State.OPEN) {
      if (cooldownExpired()) {
        // Try to move to HALF_OPEN once per thread race safely
        if (state.compareAndSet(State.OPEN, State.HALF_OPEN)) {
          halfOpenInFlight.set(0);
        }
      } else {
        return fallback.get(); // fail fast
      }
    }

    s = state.get();
    if (s == State.HALF_OPEN && halfOpenInFlight.incrementAndGet() > halfOpenMaxCalls) {
      halfOpenInFlight.decrementAndGet();
      return fallback.get(); // limit probes
    }

    try {
      T result = supplier.get();
      onSuccess();
      return result;
    } catch (Exception e) {
      onFailure(e);
      return fallback.get();
    } finally {
      if (state.get() == State.HALF_OPEN) {
        halfOpenInFlight.decrementAndGet();
      }
    }
  }

  private void onSuccess() {
    if (state.get() == State.HALF_OPEN) {
      // Success in HALF_OPEN resets breaker
      consecutiveFailures.set(0);
      state.set(State.CLOSED);
      return;
    }
    consecutiveFailures.set(0);
  }

  private void onFailure(Exception e) {
    if (state.get() == State.HALF_OPEN) {
      tripOpen();
      return;
    }
    int fails = consecutiveFailures.incrementAndGet();
    if (fails >= failureThreshold || isTimeout(e)) {
      tripOpen();
    }
  }

  private boolean isTimeout(Exception e) {
    return e instanceof TimeoutException;
  }

  private void tripOpen() {
    state.set(State.OPEN);
    openedAt.set(System.nanoTime());
  }

  private boolean cooldownExpired() {
    long nanos = System.nanoTime() - openedAt.get();
    return nanos >= openCooldown.toNanos();
  }

  private State currentState() { return state.get(); }

  public State state() { return state.get(); }

  @FunctionalInterface public interface CheckedSupplier<T> { T get() throws Exception; }
}
```

**Usage Example**

```java
public class CustomerClient {
  private final CircuitBreaker breaker =
      new CircuitBreaker(5, Duration.ofSeconds(10), 3); // 5 fails → OPEN 10s; 3 probes

  private final HttpClient http; // your adapter; ensure timeouts are set!

  public CustomerClient(HttpClient http) { this.http = http; }

  public String fetchById(String id) throws Exception {
    return breaker.call(
        () -> http.get("/customers/" + id),   // protected operation
        () -> "{}"                             // fallback (stale cache or minimal object)
    );
  }
}

// Example HttpClient adapter (simplified)
interface HttpClient { String get(String path) throws Exception; }
```

**Notes**

-   Treat **timeouts and slow calls** as failures; always set client timeouts.
    
-   For error-rate-based breakers, track a rolling window and compute failure %, not just consecutive fails.
    
-   In production, prefer a library (e.g., Resilience4j) for advanced policies, metrics, and integration.
    

---

## Known Uses

-   **API gateways / edge services:** Trip per upstream to protect the edge.
    
-   **Microservices:** Wrapping calls to payment, catalog, auth, or recommendation services.
    
-   **Database / cache drivers:** Short-circuit to read replicas or in-memory cache when primaries fail.
    
-   **Third-party integrations:** Prevent SLAs from being hostage to external outages.
    

## Related Patterns

-   **Bulkhead:** Isolate resources so a failing dependency can’t starve others; use together.
    
-   **Timeouts:** Bound call duration so failures are observable quickly.
    
-   **Retry with Exponential Backoff & Jitter:** Retry only **inside** a closed/half-open window; stop when open.
    
-   **Fallback / Graceful Degradation:** Provide alternates when breaker rejects.
    
-   **Rate Limiting / Load Shedding:** Upstream admission control to avoid overload during partial outages.
    
-   **Health Checks & Adaptive Routing:** Steer traffic away from unhealthy instances while breaker protects callers.
    

**Rule of thumb:** **Fail fast, recover safe.** Use circuit breakers to turn chaotic failure patterns into predictable, observable states that you can operate and scale.

You: 

Fill out the following chapters for the Resillience, Fault Tolerance Pattern "Dead Letter Queue": Pattern Name and Classification, Intent, Also Known As, Motivation (Forces), Applicability, Structure, Participants, Collaboration, Consequences, Implementation, Sample Code, Known Uses, Related Patterns In case code is useful provide a sample code in Java. Start with the pattern name and topic as title. Proceed with the chapters as listed. Do not provide any questions in the end.

ChatGPT: 

Nachgedacht für 25s

# Dead Letter Queue — Resilience & Fault-Tolerance Pattern

## Pattern Name and Classification

**Name:** Dead Letter Queue (DLQ)  
**Classification:** Resilience / Fault-Tolerance Pattern (Message Handling & Recovery)

## Intent

Prevent **poison messages** (malformed, unprocessable, or permanently failing) from blocking normal processing by **diverting them to a dedicated queue/topic** after a finite number of attempts, so the main flow stays healthy and failures are **quarantined for later analysis or remediation**.

## Also Known As

-   Dead Letter Channel
    
-   Poison Message Queue
    
-   Error Queue / Parking Lot Queue (variant)
    

## Motivation (Forces)

-   **Non-blocking throughput:** A single bad message must not stall a consumer or starve a partition.
    
-   **Operational clarity:** Distinguish transient failures (retry) from permanent ones (route to DLQ).
    
-   **Forensics:** Preserve the **original payload + failure context** for debugging/replay.
    
-   **Compliance:** Some domains require an audit trail of dropped/failed events.
    
-   **Cost control:** Infinite retries or stuck redelivery loops waste compute and I/O.
    

## Applicability

Use a DLQ when:

-   You process messages/events asynchronously (MQ, Kafka, SQS, Pub/Sub).
    
-   Producers/consumers are independent and you can’t guarantee schema compatibility at all times.
    
-   Retries are bounded; after N attempts you must **fail safely**.
    
-   You need to **inspect & replay** failures without impacting the hot path.
    

Avoid / tune differently when:

-   Message loss is unacceptable **and** you can always fix and reprocess inline (rare).
    
-   All failures are transient (network only) and backoff+retry already suffices.
    
-   The platform provides a better **parking lot** pattern (manual triage with delayed retry) that you intend to use.
    

## Structure

```pgsql
┌──────────────┐     success        ┌──────────────┐
Producer │  Main Topic  │ ─────────────────► │   Consumer   │
         └──────┬───────┘                    └──────┬───────┘
                │  on permanent failure              │
                │  (after N retries)                 │
                ▼                                     ▼
         ┌──────────────┐    copy of msg +     ┌──────────────┐
         │   DLQ Topic  │◄── error metadata ───│  DLQ Handler │
         └──────────────┘                        (ops/repair/replay)
```

## Participants

-   **Main Queue/Topic:** Primary stream of work.
    
-   **Consumer:** Processes messages, applies retry policy, and ultimately decides to dead-letter.
    
-   **Dead Letter Queue/Topic:** Quarantine for failed messages (immutable storage).
    
-   **DLQ Handler / Ops Tools:** Dashboards, alerts, triage jobs, replay utilities.
    
-   **Metadata/Headers:** Carry failure cause, stack, retry count, timestamps, schema version, etc.
    

## Collaboration

1.  **Consume → Process → Ack/Commit** on success.
    
2.  **Retry** transient failures with bounded attempts and backoff.
    
3.  **Dead-letter** after limit: publish the original message plus failure metadata to the DLQ; **commit/ack** the failed offset to unblock the main stream.
    
4.  **Observe & Act:** Alert on DLQ rate; ops investigate, fix upstream, or **replay** from DLQ to a **retry topic** or back to main after correction.
    

## Consequences

**Benefits**

-   **Isolation:** Poison messages no longer clog partitions or threads.
    
-   **Operability:** Clear backlog of problematic events for later remediation.
    
-   **Auditability:** Durable trail of failures with rich context.
    
-   **SLO protection:** Keeps latency/throughput of healthy traffic predictable.
    

**Liabilities / Trade-offs**

-   **Operational pipeline required:** Someone must own triage+replay.
    
-   **Storage growth:** DLQ can accumulate; needs retention & governance.
    
-   **Risk of re-poisoning:** Blind replay can reintroduce bad events—require fixes or quarantine staging.
    
-   **Duplication semantics:** Reprocessing must be **idempotent** to avoid side effects.
    

## Implementation

1.  **Define failure policy:** max attempts, which exceptions are **non-retryable**, backoff (exponential + jitter).
    
2.  **Carry context:** When dead-lettering, include headers: `x-retry-count`, `x-exception-class`, `x-exception-msg`, `x-stack`, `x-original-topic`, `x-original-partition`, `x-offset`, `x-timestamp`, `x-schema-version`.
    
3.  **Commit wisely:** After publishing to DLQ, **commit/ack** the original message to prevent endless loops.
    
4.  **Observe:** Emit metrics on retries, DLQ publishes, and per-cause counts; alert on spikes.
    
5.  **Retention & access:** Size DLQ retention; protect PII; consider encryption at rest.
    
6.  **Replay tooling:** Build a **controlled replay** path (rate-limited, idempotent) from DLQ to a *retry topic* or back to main after fixes.
    
7.  **Governance:** Document who owns DLQ triage, SLAs for cleanup, and a runbook.
    

---

## Sample Code (Java)

### Example: Spring for Apache Kafka — Bounded retries + DeadLetterPublishingRecoverer

```java
// build.gradle (relevant dependencies)
// implementation 'org.springframework.kafka:spring-kafka'

import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.common.TopicPartition;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.kafka.config.ConcurrentKafkaListenerContainerFactory;
import org.springframework.kafka.core.KafkaTemplate;
import org.springframework.kafka.listener.DefaultErrorHandler;
import org.springframework.kafka.listener.DeadLetterPublishingRecoverer;
import org.springframework.util.backoff.ExponentialBackOffWithMaxRetries;

@Configuration
public class KafkaDlqConfig {

  public static final String MAIN_TOPIC = "orders.v1";
  public static final String DLQ_SUFFIX = ".DLT"; // Dead Letter Topic naming convention

  @Bean
  public DeadLetterPublishingRecoverer dlqRecoverer(KafkaTemplate<Object, Object> template) {
    return new DeadLetterPublishingRecoverer(template, (record, ex) -> {
      // route to "<original-topic>.DLT" with same partition by default
      String dlqTopic = record.topic() + DLQ_SUFFIX;
      return new TopicPartition(dlqTopic, record.partition());
    });
  }

  @Bean
  public DefaultErrorHandler errorHandler(DeadLetterPublishingRecoverer recoverer) {
    var backoff = new ExponentialBackOffWithMaxRetries(3); // 3 retries
    backoff.setInitialInterval(200L);
    backoff.setMultiplier(2.0);
    backoff.setMaxInterval(2_000L);

    var handler = new DefaultErrorHandler(recoverer, backoff);

    // Mark specific exceptions as non-retryable -> immediate DLQ
    handler.addNotRetryableExceptions(
        javax.validation.ConstraintViolationException.class,
        com.fasterxml.jackson.core.JsonParseException.class
    );

    // Optionally enrich headers on DLQ publication
    handler.setRecoverer((record, ex) -> {
      record.headers()
            .add("x-exception-class", ex.getClass().getName().getBytes())
            .add("x-exception-message", String.valueOf(ex.getMessage()).getBytes())
            .add("x-original-topic", record.topic().getBytes());
      // delegate to publisher
      dlqRecoverer(template()).accept(record, ex);
    });

    return handler;
  }

  // Wire the container factory to use our error handler
  @Bean
  public ConcurrentKafkaListenerContainerFactory<String, String> kafkaListenerContainerFactory(
      org.springframework.kafka.core.ConsumerFactory<String, String> consumerFactory,
      DefaultErrorHandler errorHandler) {

    var factory = new ConcurrentKafkaListenerContainerFactory<String, String>();
    factory.setConsumerFactory(consumerFactory);
    factory.setCommonErrorHandler(errorHandler);
    factory.setAckDiscarded(true); // commit offsets when discarded to DLQ
    return factory;
  }

  // Provide KafkaTemplate bean
  @Bean
  public KafkaTemplate<Object, Object> template() {
    return new KafkaTemplate<>(/* producerFactory bean here */);
  }
}
```

```java
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.springframework.kafka.annotation.KafkaListener;
import org.springframework.stereotype.Service;

@Service
public class OrderConsumer {

  @KafkaListener(topics = KafkaDlqConfig.MAIN_TOPIC, groupId = "orders-processor")
  public void onMessage(ConsumerRecord<String, String> record) {
    var payload = record.value();

    // Example validation that might throw
    if (!payload.contains("\"orderId\"")) {
      throw new IllegalArgumentException("Missing orderId");
    }

    // Process business logic here...
  }
}
```

**What this gives you**

-   Up to **3 retries** with exponential backoff on transient errors.
    
-   Immediate **dead-lettering** for non-retryable exceptions (e.g., schema/validation).
    
-   DLQ messages land in `<originalTopic>.DLT` with original headers + error context; the failed offset is **committed**, unblocking the partition.
    
-   You can add a separate **DLQ consumer** to alert, store, or **replay** after fixes.
    

---

## Known Uses

-   **Kafka / Pulsar:** `<topic>.DLT` or dedicated DLQ topics managed by consumer frameworks (Spring Kafka, Debezium, Kafka Connect DLQ).
    
-   **RabbitMQ:** Queue bound to an exchange with `x-dead-letter-exchange` / `x-dead-letter-routing-key`.
    
-   **AWS SQS/SNS:** Native redrive policy to a DLQ after `maxReceiveCount`.
    
-   **Azure Service Bus / GCP Pub/Sub:** Built-in dead-lettering with reason & description maintained in metadata.
    
-   **ETL pipelines:** Malformed rows/events routed to an **error stream** for investigation.
    

## Related Patterns

-   **Retry with Exponential Backoff & Jitter:** Attempts before dead-lettering; ensure bounded retries.
    
-   **Circuit Breaker:** Protects the **caller**; DLQ protects the **stream** from poison data.
    
-   **Bulkhead:** Isolate processing pools so spikes or poison messages don’t starve unrelated work.
    
-   **Idempotent Consumer / Exactly-Once Effects:** Make replay safe.
    
-   **Schema Evolution / Consumer-Driven Contracts:** Reduce DLQ volume by preventing breaking changes.
    
-   **Parking Lot Queue:** Manual triage queue for later reprocessing with human approval.
    
-   **Competing Consumers / Queue-based Load Leveling:** Complementary to keep throughput stable despite DLQ detours.
    

**Practical tip:** **Dead-letter early, debug offline.** Keep hot paths fast and predictable; invest in DLQ observability and safe replay to close the loop.

You: 

Fill out the following chapters for the Resillience, Fault Tolerance Pattern "Fail Fast": Pattern Name and Classification, Intent, Also Known As, Motivation (Forces), Applicability, Structure, Participants, Collaboration, Consequences, Implementation, Sample Code, Known Uses, Related Patterns In case code is useful provide a sample code in Java. Start with the pattern name and topic as title. Proceed with the chapters as listed. Do not provide any questions in the end.

ChatGPT: 

Nachgedacht für 14s

# Fail Fast — Resilience & Fault-Tolerance Pattern

## Pattern Name and Classification

**Name:** Fail Fast  
**Classification:** Resilience / Fault-Tolerance Pattern (Fast Rejection & Early Error Detection)

## Intent

Detect invalid states, unavailable dependencies, or capacity exhaustion **as early as possible** and return an error immediately instead of waiting (e.g., on long timeouts or unbounded queues). This preserves resources, prevents cascades, and keeps latency predictable.

## Also Known As

-   Fast Rejection
    
-   Guard Clauses / Early Return (at method level)
    
-   Quick Fail Admission Control
    

## Motivation (Forces)

-   **Latency budgets:** Slow timeouts pile up, saturating threads and connections.
    
-   **Predictability:** It’s better to return a clear “can’t serve now” quickly than to stall.
    
-   **Backpressure:** Upstream can shed or reroute load when it receives immediate rejections.
    
-   **Simplicity:** Early, explicit checks make intent obvious and reduce error-handling complexity later.
    

Counter-forces:

-   Over-eager rejections can degrade availability if thresholds are tuned too aggressively.
    
-   Some workflows prefer “eventual” success over immediate failure (e.g., batch jobs).
    

## Applicability

Use Fail Fast when:

-   Requests exceed **capacity**, queues are full, or concurrency limits are hit.
    
-   **Preconditions** or **input validation** can be checked upfront.
    
-   A **dependency** is known unhealthy (e.g., circuit breaker is OPEN).
    
-   **Timeouts** should be strict and short; waiting offers no benefit.
    

Avoid or tune carefully when:

-   Work is rare/cheap and transient glitches would self-heal if you waited a bit.
    
-   You must guarantee in-line retries instead of surfacing errors to callers.
    

## Structure

```java
Client ──► Admission Guards (capacity / health / validation)
            ├─ pass ─► Do Work (short, bounded)
            └─ reject fast ─► Error / Fallback / Queue for later
```

## Participants

-   **Admission Guard(s):** Checks capacity, health, and preconditions; may include rate limiters, semaphores, and circuit breakers.
    
-   **Work Executor:** Performs the actual task under strict timeouts.
    
-   **Fallback / Degrader (optional):** Returns cached/partial results on fast rejection.
    
-   **Metrics/Alarms:** Counters for rejections/timeouts to inform tuning and autoscaling.
    

## Collaboration

-   The caller first hits **guards**; if any guard rejects, it returns immediately (possibly with a fallback).
    
-   If accepted, the executor runs the task **with a short timeout**.
    
-   Fail Fast composes with **Bulkheads** (isolation), **Circuit Breakers** (health gating), and **Retries** (but only when allowed).
    

## Consequences

**Benefits**

-   Prevents queues/threads from **filling with hopeless work**.
    
-   Keeps tail latency under control; protects SLOs for healthy requests.
    
-   Produces clearer failure signals for autoscaling and routing.
    

**Liabilities / Trade-offs**

-   Requires **tuning** of limits and timeouts; misconfiguration causes flapping or excessive errors.
    
-   Pushes complexity to **callers**, who must handle fast failures and retry or degrade.
    

## Implementation

1.  **Identify guard points**: validation, auth, dependency health, capacity (concurrency/queue).
    
2.  **Set strict limits**: use **bounded** queues and **short, deterministic timeouts**.
    
3.  **Compose guards**: order checks from cheapest to most expensive (validation → capacity → health).
    
4.  **Provide fallbacks**: cached data, defaults, “try again later.”
    
5.  **Instrument**: expose metrics for rejections, timeouts, and success; alert on spikes.
    
6.  **Tune with data**: load test; adjust limits/timeout budgets based on p95/p99.
    

---

## Sample Code (Java)

### A) A minimal Fail-Fast guard with capacity, health, and timeout

```java
import java.time.Duration;
import java.util.Objects;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.function.Supplier;

/** Simple fail-fast wrapper for calls to a downstream or expensive task. */
public class FailFastGuard {

  private final Semaphore capacity;                // concurrency bulkhead
  private final AtomicBoolean dependencyHealthy;   // e.g., from a circuit breaker
  private final Duration timeout;                  // strict per-call timeout
  private final ExecutorService executor;          // short-lived workers or a shared pool

  public FailFastGuard(int maxConcurrent, Duration timeout, Supplier<Boolean> healthSupplier) {
    this.capacity = new Semaphore(maxConcurrent);
    this.timeout = Objects.requireNonNull(timeout);
    this.dependencyHealthy = new AtomicBoolean(true);
    // Optionally wire healthSupplier to update dependencyHealthy asynchronously
    this.executor = Executors.newFixedThreadPool(Math.max(2, maxConcurrent));
    // A very simple poller (optional)
    Executors.newSingleThreadScheduledExecutor().scheduleAtFixedRate(
        () -> dependencyHealthy.set(Boolean.TRUE.equals(healthSupplier.get())), 0, 500, TimeUnit.MILLISECONDS);
  }

  /** Execute the task if guards pass; otherwise fast-fail or return fallback. */
  public <T> T call(Callable<T> task, Supplier<T> fallback) throws Exception {
    // 1) Validate health first (cheap)
    if (!dependencyHealthy.get()) {
      return fallback.get(); // fast reject
    }
    // 2) Capacity check (no queue growth)
    if (!capacity.tryAcquire()) {
      return fallback.get(); // fast reject on overload
    }
    try {
      Future<T> f = executor.submit(task);
      return f.get(timeout.toMillis(), TimeUnit.MILLISECONDS); // 3) strict timeout
    } catch (TimeoutException te) {
      return fallback.get(); // treat timeout as fast failure; cancel work
    } finally {
      capacity.release();
    }
  }

  public void shutdown() { executor.shutdownNow(); }
}
```

**Usage example**

```java
public class ProfileClient {
  private final FailFastGuard guard = new FailFastGuard(
      32, Duration.ofMillis(300), this::isUpstreamHealthy);

  private final HttpClient http; // your adapter with its own short timeouts

  public ProfileClient(HttpClient http) { this.http = http; }

  public String getProfile(String userId) throws Exception {
    return guard.call(
        () -> http.get("/profiles/" + userId),             // protected operation
        () -> "{\"status\":\"degraded\",\"userId\":\"" + userId + "\"}" // fallback
    );
  }

  private Boolean isUpstreamHealthy() {
    // Use circuit breaker state, health endpoint ping, or last success timestamp
    return http.isHealthy();
  }

  interface HttpClient {
    String get(String path) throws Exception;
    boolean isHealthy();
  }
}
```

### B) Fail-Fast at method level with guard clauses (validation + quick exits)

```java
public class BookingService {
  public Reservation book(BookingRequest req, User user) {
    // Guard: input validation
    if (req == null) return Reservation.rejected("Missing request");
    if (user == null) return Reservation.rejected("Missing user");
    if (!user.hasPermission("BOOK")) return Reservation.rejected("Not authorized");
    if (req.date().isBefore(java.time.LocalDate.now())) return Reservation.rejected("Date in the past");

    // Happy path (short and bounded)
    return reserve(req).orElse(Reservation.rejected("No availability"));
  }

  private java.util.Optional<Reservation> reserve(BookingRequest req) {
    // call into inventory with its own small timeout; no unbounded waits
    return java.util.Optional.of(new Reservation(/* ... */));
  }
}
```

### C) Fast-rejecting queue (bounded) for work intake

```java
public class IngressQueue<T> {
  private final BlockingQueue<T> q = new ArrayBlockingQueue<>(1000); // bounded

  /** Returns false immediately when full (fail fast). */
  public boolean offer(T item) {
    return q.offer(item); // no waiting; caller decides to drop/fallback/shed load
  }

  public T take() throws InterruptedException {
    return q.take();
  }
}
```

---

## Known Uses

-   **API gateways:** Immediate 429/503 when rate limits or concurrency caps are exceeded.
    
-   **Microservices:** Quick rejection when a **circuit breaker is OPEN** or a **bulkhead** is saturated.
    
-   **Datastores/HTTP clients:** Small client timeouts (100–500 ms) for interactive paths rather than multi-second waits.
    
-   **Job schedulers:** Bounded queues that reject new jobs during surge, pushing to a retry queue instead.
    
-   **Validation layers:** Guard clauses at the top of handlers/services to stop bad requests early.
    

## Related Patterns

-   **Bulkhead:** Provides the concurrency limit that triggers fast rejection.
    
-   **Circuit Breaker:** Signals unhealthy downstreams so calls are rejected immediately.
    
-   **Timeouts:** Enforce strict upper bounds on work duration.
    
-   **Rate Limiting / Load Shedding:** Admission control that often implements fail-fast behavior.
    
-   **Fallback / Graceful Degradation:** What you return when you reject quickly.
    
-   **Retry with Backoff & Jitter:** Retrying should respect fast-fail signals and capacity caps.
    
-   **Guard Clauses / Simplify Nested Conditional:** Coding technique for early returns at method level.
    

**Rule of thumb:** If a request **can’t** be served within the latency budget or violates preconditions, **say so immediately**—don’t make the system suffer in silence.

You: 

Fill out the following chapters for the Resillience, Fault Tolerance Pattern "Fallback": Pattern Name and Classification, Intent, Also Known As, Motivation (Forces), Applicability, Structure, Participants, Collaboration, Consequences, Implementation, Sample Code, Known Uses, Related Patterns In case code is useful provide a sample code in Java. Start with the pattern name and topic as title. Proceed with the chapters as listed. Do not provide any questions in the end.

ChatGPT: 

Nachgedacht für 8s

# Fallback — Resilience & Fault-Tolerance Pattern

## Pattern Name and Classification

**Name:** Fallback  
**Classification:** Resilience / Fault-Tolerance Pattern (Graceful Degradation & Alternate Path)

## Intent

When the primary operation **fails, times out, or is unavailable**, return a **safe alternative**—such as cached/stale data, a default result, a reduced-quality response, or a different provider—so the system degrades gracefully instead of failing catastrophically.

## Also Known As

-   Graceful Degradation
    
-   Default Response / Safe Default
    
-   Substitute / Alternative Path
    
-   Degraded Mode
    

## Motivation (Forces)

-   **Availability over perfection:** Users prefer partial results to hard errors during incidents.
    
-   **Dependency fragility:** Remote services, data stores, or models can fail or slow down.
    
-   **User experience:** Keeping core journeys working (even with reduced fidelity) preserves trust and revenue.
    
-   **Operational clarity:** Predictable degraded responses are easier to monitor than sporadic timeouts.
    

Counter-forces:

-   **Staleness and correctness risks:** Old or approximate data may mislead.
    
-   **Hidden failures:** Overuse can mask real problems if not instrumented.
    

## Applicability

Use Fallback when:

-   There is a **meaningful substitute** (default value, last-known good, subset, synthetic answer).
    
-   The cost of failure is high and **SLAs favor availability**.
    
-   You can **bound staleness** and communicate degradation.
    
-   Combined with **Circuit Breaker/Bulkhead/Timeouts** to decide when to invoke the fallback.
    

Avoid or tune carefully when:

-   Domain requires **strong consistency or correctness** (e.g., payments, legal compliance).
    
-   Returning stale/approximate data causes harm or security issues.
    
-   Fallback could trigger **feedback loops** (e.g., caching errors).
    

## Structure

```sql
Client ──► Primary Operation (may fail/timeout)
             │ success
             └──────────────► Return primary result
             │ failure/timeout/rejection
             ▼
          Fallback Strategy (cache/default/alt provider/partial)
             │
             └──────────────► Return degraded result (+ signal/metrics)
```

## Participants

-   **Caller / Orchestrator:** Wraps the primary call and applies fallback on failure.
    
-   **Primary Operation:** The preferred dependency or algorithm.
    
-   **Fallback Strategy:** Defines how to produce an alternative (cache, default, stub, alt provider).
    
-   **Policy / Guard:** Circuit breaker, timeout, bulkhead, or error classifier that triggers fallback.
    
-   **Telemetry:** Metrics, logs, and headers/tags indicating degraded responses.
    

## Collaboration

-   Caller invokes **primary → guard**; on failure or rejection, selects and executes **fallback**.
    
-   Fallback may consult **caches**, **read replicas**, or **precomputed summaries**.
    
-   The response is **tagged** (e.g., header `X-Degraded: true`) and metrics are emitted to avoid masking incidents.
    

## Consequences

**Benefits**

-   Maintains availability under partial failures.
    
-   Protects latency budgets (fast degraded responses).
    
-   Reduces cascade effects and support load.
    

**Liabilities / Trade-offs**

-   Possible **stale/approximate** data.
    
-   Risk of **overuse** hiding systemic issues—must alert on fallback usage.
    
-   Extra code paths to maintain and test.
    

## Implementation

1.  **Define failure classes:** timeouts, connection errors, 5xx, circuit-open, validation errors.
    
2.  **Choose fallback type(s):**
    
    -   **Static default:** constant or empty structure.
        
    -   **Stale cache / last-known good (LKG):** bounded by TTL or version.
        
    -   **Alternative provider:** secondary service/region/read-replica.
        
    -   **Partial result:** subset without expensive parts.
        
3.  **Order of operations:** Typically **Bulkhead → Timeout → Circuit Breaker → (on failure) Fallback**.
    
4.  **Bound staleness:** TTL for cache; attach freshness metadata.
    
5.  **Signal degradation:** Add logs/metrics/headers; surface to UX if appropriate.
    
6.  **Test:** Chaos/fault injection; verify correctness, staleness bounds, and usability.
    
7.  **Govern:** Decide which endpoints may degrade; document user-visible effects.
    

---

## Sample Code (Java)

### A) Lightweight fallback wrapper with cache/LKG and alternative provider

```java
import java.time.*;
import java.util.Optional;
import java.util.concurrent.*;
import java.util.function.Supplier;

/** A simple fallback orchestrator: primary → alt → last-known-good → default. */
public class Fallbacks<T> {

  private final ExecutorService pool = Executors.newCachedThreadPool();

  // Last-Known-Good cache with timestamp
  private volatile T lastKnownGood;
  private volatile Instant lastUpdate = Instant.EPOCH;
  private final Duration lkgTtl;

  public Fallbacks(Duration lkgTtl) {
    this.lkgTtl = lkgTtl;
  }

  public void updateLkg(T value) {
    lastKnownGood = value;
    lastUpdate = Instant.now();
  }

  /** Executes primary with timeout; falls back to alternative, then LKG (if fresh), then default. */
  public T call(
      Callable<T> primary,
      Duration timeout,
      Optional<Supplier<T>> alternative,
      Optional<Supplier<T>> defaultValue) throws Exception {

    try {
      Future<T> f = pool.submit(primary);
      T result = f.get(timeout.toMillis(), TimeUnit.MILLISECONDS);
      updateLkg(result); // refresh LKG on success
      return result;
    } catch (Exception primaryFailure) {

      // 1) Alternative provider
      if (alternative.isPresent()) {
        try {
          T alt = alternative.get().get();
          updateLkg(alt);
          return alt;
        } catch (Exception ignore) {
          // fall through
        }
      }

      // 2) Last-known-good if fresh enough
      if (lastKnownGood != null && Duration.between(lastUpdate, Instant.now()).compareTo(lkgTtl) <= 0) {
        return lastKnownGood;
      }

      // 3) Static default (final safety net)
      if (defaultValue.isPresent()) {
        return defaultValue.get().get();
      }

      // 4) Rethrow if no fallback possible
      throw primaryFailure;
    }
  }

  public void shutdown() { pool.shutdownNow(); }
}
```

**Example usage (HTTP with alt provider and LKG):**

```java
public class ProductClient {

  private final Fallbacks<String> fb = new Fallbacks<>(Duration.ofSeconds(30));
  private final Http httpPrimary;  // e.g., https://api-primary
  private final Http httpAlt;      // e.g., https://api-secondary

  public ProductClient(Http primary, Http alt) {
    this.httpPrimary = primary; this.httpAlt = alt;
  }

  public String getProduct(String id) throws Exception {
    return fb.call(
        () -> httpPrimary.get("/products/" + id),           // primary
        Duration.ofMillis(300),                              // strict timeout
        Optional.of(() -> httpAlt.get("/products/" + id)),   // alternative region
        Optional.of(() -> "{\"id\":\"" + id + "\",\"status\":\"degraded\"}") // default
    );
  }

  interface Http { String get(String path) throws Exception; }
}
```

### B) Fallback combined with a Circuit Breaker (sketch)

```java
public class SafeClient {
  private final CircuitBreaker breaker; // from your implementation or library
  private final Fallbacks<String> fallbacks = new Fallbacks<>(Duration.ofSeconds(60));
  private final Http http;

  public SafeClient(CircuitBreaker breaker, Http http) {
    this.breaker = breaker; this.http = http;
  }

  public String fetch(String path) throws Exception {
    return breaker.call(
        () -> fallbacks.call(
              () -> http.get(path),
              Duration.ofMillis(250),
              Optional.empty(),
              Optional.of(() -> "{\"status\":\"degraded\"}")
        ),
        () -> "{\"status\":\"circuit-open\"}" // breaker-level fallback
    );
  }

  interface Http { String get(String path) throws Exception; }
}
```

### C) Returning partial results (degraded computation)

```java
public class RecommendationsService {

  public Recommendations getHomeRecommendations(String userId) {
    try {
      // Full model (might be slow)
      return computeWithHeavyModel(userId);
    } catch (Exception e) {
      // Fallback: popularity-only, no personalization
      return topPopularFallback();
    }
  }

  private Recommendations computeWithHeavyModel(String userId) { /* ... */ return new Recommendations(/* ... */); }
  private Recommendations topPopularFallback() { /* ... */ return new Recommendations(/* popular only */); }

  static class Recommendations { /* fields omitted */ }
}
```

---

## Known Uses

-   **E-commerce:** If pricing service is down, show product info without dynamic discounts; if recommendations fail, show popular items.
    
-   **Content feeds:** Serve cached timeline when personalization backend is unavailable.
    
-   **Maps/Geo:** Fall back to coarse geolocation or static tiles when live routing fails.
    
-   **ML/AI features:** Use a simpler heuristic/model when the main model is unavailable.
    
-   **Payments (carefully):** Switch to **read-only** mode (show balances, disable transfers) when write path is unhealthy.
    

## Related Patterns

-   **Circuit Breaker:** Decides when to stop calling the primary and **immediately** use fallback.
    
-   **Timeouts:** Bound primary latency; trigger fallback predictably.
    
-   **Bulkhead:** Keep capacity for serving fallbacks and healthy traffic.
    
-   **Fail Fast:** Reject quickly and return fallback/default instead of waiting.
    
-   **Cache-Aside / LKG (Last-Known-Good):** Common fallback source; ensure TTLs and invalidation.
    
-   **Retry with Backoff & Jitter:** Try a few times before falling back—**but** not indefinitely.
    
-   **Feature Flags / Degraded Mode Switch:** Toggle fallbacks system-wide during incidents.
    

**Practical tip:** Decide **per endpoint** what “good enough” means, **bound staleness**, and **measure fallback rates**—if they spike, raise an alert and investigate the primary path.

You: 

Fill out the following chapters for the Resillience, Fault Tolerance Pattern "Graceful Degredation": Pattern Name and Classification, Intent, Also Known As, Motivation (Forces), Applicability, Structure, Participants, Collaboration, Consequences, Implementation, Sample Code, Known Uses, Related Patterns In case code is useful provide a sample code in Java. Start with the pattern name and topic as title. Proceed with the chapters as listed. Do not provide any questions in the end.

ChatGPT: 

Nachgedacht für 6s

# Graceful Degradation — Resilience & Fault-Tolerance Pattern

## Pattern Name and Classification

**Name:** Graceful Degradation  
**Classification:** Resilience / Fault-Tolerance Pattern (Progressive Feature Reduction & UX Preservation)

## Intent

When portions of a system are **unavailable, slow, or overloaded**, keep core journeys working by **reducing quality or scope** (e.g., omit non-critical features, serve cached/stale data, downscale fidelity) instead of failing the whole request.

## Also Known As

-   Progressive Degradation
    
-   Degraded Mode
    
-   Best-Effort Service
    
-   Tiered Quality of Service (QoS)
    

## Motivation (Forces)

-   **Availability over completeness:** Users often prefer timely, partial results to errors or timeouts.
    
-   **Complex dependencies:** Modern apps rely on multiple downstreams (search, personalization, payments, media). Some can fail without blocking the core path.
    
-   **Latency budgets/SLOs:** It’s better to skip optional work than to blow p95/p99.
    
-   **Cost control:** During surges, purposefully shed non-essential work to protect critical capacity.
    

Counter-forces:

-   **Correctness/consistency:** Some domains can’t tolerate approximation.
    
-   **Hidden incidents:** If not instrumented, degradation can mask failures.
    

## Applicability

Use Graceful Degradation when:

-   You can **rank features** by criticality (must-have vs. nice-to-have).
    
-   There are **safe substitutes** (cached data, placeholders, defaults).
    
-   The UI/API can **signal partial results** to consumers.
    
-   You have **signals** (circuit state, error rates, queue depth) to trigger mode changes.
    

Avoid or limit when:

-   Regulatory or financial correctness requires full fidelity.
    
-   Partial output could be misleading or unsafe.
    

## Structure

```sql
Request
  ├── Guard/Health checks (bulkhead, timeout, circuit)
  ├── Execute essential path (must not degrade)
  ├── Try optional features in priority order with small budgets
  │     ├── if slow/failing → skip/replace with cached/default
  │     └── record degradation
  └── Respond with result + metadata (e.g., X-Degraded: true; components omitted)
```

## Participants

-   **Degradation Controller/Policy:** Decides which features to drop by priority and current health/load.
    
-   **Essential Components:** Must run; otherwise the request fails.
    
-   **Optional Components:** Added when healthy; skipped or approximated when not.
    
-   **Fallback Providers:** Cache/LKG, secondary providers, placeholders.
    
-   **Telemetry:** Counters, traces, and headers that indicate degradation.
    

## Collaboration

-   Guards (timeouts, bulkheads, circuit breakers) provide **signals** and enforce budgets.
    
-   The controller **orchestrates** calls to optional components with tiny timeboxes; on failure it uses a fallback and marks the response as degraded.
    
-   The client (UI/API consumer) **honors metadata** to adjust presentation (e.g., hide widgets).
    

## Consequences

**Benefits**

-   Preserves core UX/SLOs under partial failure or load spikes.
    
-   Reduces cascading failures by not waiting on non-critical paths.
    
-   Produces **measurable** degrade events that drive autoscaling and incident response.
    

**Liabilities / Trade-offs**

-   Stale or incomplete data; must communicate clearly.
    
-   Additional code paths and testing matrix.
    
-   Poor observability can normalize degraded state.
    

## Implementation

1.  **Classify features:** must-have, important, nice-to-have.
    
2.  **Define budgets:** small timeouts for optional features (e.g., 50–150 ms each).
    
3.  **Add fallbacks:** cache/LKG, placeholders, simpler algorithms or secondary regions.
    
4.  **Centralize policy:** a controller that applies the same degrade rules everywhere.
    
5.  **Propagate signals:** response headers/flags (e.g., `X-Degraded: true`, `X-Degraded-Parts: recs,ratings`).
    
6.  **Instrument:** counters for degraded responses by reason, feature, and endpoint.
    
7.  **Chaos test:** inject failures/latency to verify UX and metrics.
    
8.  **Govern:** document which endpoints may degrade and how UX should adapt.
    

---

## Sample Code (Java)

**Scenario:** Product page renders even if recommendations/ratings are down. We protect the essential product fetch and degrade optional features with time-boxed calls, fallbacks, and response flags.

```java
import java.time.Duration;
import java.util.*;
import java.util.concurrent.*;
import java.util.function.Supplier;

public class ProductFacade {

  private final ExecutorService pool = Executors.newFixedThreadPool(64);

  private final ProductApi productApi;           // essential
  private final RecommendationsApi recsApi;      // optional
  private final RatingsApi ratingsApi;           // optional

  // tiny budgets for optional features
  private static final Duration RECS_BUDGET   = Duration.ofMillis(120);
  private static final Duration RATINGS_BUDGET= Duration.ofMillis(80);

  public ProductFacade(ProductApi productApi, RecommendationsApi recsApi, RatingsApi ratingsApi) {
    this.productApi = productApi;
    this.recsApi = recsApi;
    this.ratingsApi = ratingsApi;
  }

  public ProductResponse getProductPage(String id) throws Exception {
    // 1) Essential path (fail if unavailable)
    Product core = timebox(() -> productApi.getProduct(id), Duration.ofMillis(300))
        .orElseThrow(() -> new IllegalStateException("Product unavailable"));

    // 2) Optional features (best effort)
    List<Product> recs = timebox(() -> recsApi.topFor(id), RECS_BUDGET)
        .orElseGet(List::of); // degrade to empty list

    OptionalDouble rating = timebox(() -> ratingsApi.averageFor(id), RATINGS_BUDGET)
        .map(OptionalDouble::of).orElse(OptionalDouble.empty()); // degrade to missing

    // 3) Compose response + signal degradation
    boolean degraded = recs.isEmpty() || rating.isEmpty();
    Set<String> parts = new HashSet<>();
    if (recs.isEmpty()) parts.add("recs");
    if (rating.isEmpty()) parts.add("ratings");

    return new ProductResponse(core, recs, rating, degraded, parts);
  }

  // Helper: run task with timeout, treat exceptions/timeouts as empty
  private <T> Optional<T> timebox(Callable<T> task, Duration budget) {
    Future<T> f = pool.submit(task);
    try {
      return Optional.ofNullable(f.get(budget.toMillis(), TimeUnit.MILLISECONDS));
    } catch (Exception e) {
      f.cancel(true);
      return Optional.empty();
    }
  }

  // --- APIs & DTOs ---

  public interface ProductApi { Product getProduct(String id) throws Exception; }
  public interface RecommendationsApi { List<Product> topFor(String productId) throws Exception; }
  public interface RatingsApi { double averageFor(String productId) throws Exception; }

  public static final class Product {
    public final String id; public final String name;
    public Product(String id, String name) { this.id = id; this.name = name; }
  }

  public static final class ProductResponse {
    public final Product product;
    public final List<Product> recommendations;
    public final OptionalDouble rating;
    public final boolean degraded;
    public final Set<String> degradedParts;

    public ProductResponse(Product product, List<Product> recommendations, OptionalDouble rating,
                           boolean degraded, Set<String> degradedParts) {
      this.product = product;
      this.recommendations = recommendations;
      this.rating = rating;
      this.degraded = degraded;
      this.degradedParts = Collections.unmodifiableSet(degradedParts);
    }

    /** Example of surfacing metadata as headers (for a web framework/controller). */
    public Map<String, String> headers() {
      Map<String, String> h = new HashMap<>();
      h.put("X-Degraded", String.valueOf(degraded));
      if (degraded && !degradedParts.isEmpty()) {
        h.put("X-Degraded-Parts", String.join(",", degradedParts));
      }
      return h;
    }
  }
}
```

**Notes**

-   Protect optional components with **tiny timeouts**. Do **not** block the page for them.
    
-   Pair with **circuit breakers**; if a dependency is OPEN, skip calling it and mark degraded.
    
-   Cache successful optional results (LKG) to improve perceived quality while the dependency heals.
    

---

## Known Uses

-   **E-commerce PDP/checkout:** Show product + price even if recommendations, reviews, or dynamic promos fail; disable coupon validation if promo engine is down (read-only mode).
    
-   **News/feeds:** Serve cached timeline and omit live counts or personalization when signals degrade.
    
-   **Maps/geo:** Show static tiles without traffic overlays when live routing is down.
    
-   **Video/ML services:** Reduce bitrate/model size or switch to a heuristic model under load.
    
-   **Enterprise portals:** Render shell/navigation and lazy-load widgets; hide non-critical widgets if sources fail.
    

## Related Patterns

-   **Fallback:** The concrete alternate result used within degraded mode.
    
-   **Fail Fast:** Quickly decide to degrade instead of waiting on optional paths.
    
-   **Bulkhead:** Reserve capacity for essentials while limiting optional features.
    
-   **Circuit Breaker:** Skip unhealthy dependencies and enter degraded mode.
    
-   **Timeouts:** Enforce strict budgets per optional feature.
    
-   **Feature Flags:** Flip system-wide to “degraded mode” during incidents.
    
-   **Cache-Aside / Last-Known-Good:** Common sources of data for degraded responses.
    

**Guideline:** Decide **in advance** what’s essential vs. optional, **budget tightly** for optional features, and **signal degradation** so users and operators know what happened.
